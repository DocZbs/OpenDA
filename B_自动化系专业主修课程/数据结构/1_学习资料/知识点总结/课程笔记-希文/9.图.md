相互之间均可能存在二元关系的一组对象，从数据结构的角度分类，属于非线性结构（non-linear structure）。此类一般性的二元关系，属于图论的研究范畴。从算法的角度对此类结构的处理策略，是通过遍历将其转化为半线性结构，从而借助树结构已有的处理方法和技巧，最终解决问题。

## 图论概述

**图**

图可定义为$G=(V, E)$。其中，集合V中的元素称作顶点（vertex）；集合E中的元素分别对应于V中的某一对顶点（u，v），表示它们之间存在某种关系，故亦称作边。

我们约定V和E均为有限集, 通常将其规模分别记 $n=|V|$ 和 $=|E|$

**无向图、有向图与混合图**

若边 $(u, v)$ 所对应顶点 $u$ 和v的次序无所谓, 则称作无向边 (undirected edge)。反之若u和v不对等, 则称 $(u, v)$ 为有向边 (directed edge)。

约定有向边 $(u, v)$ 从u指向v, 其中u称作该边的起点 (origin) 或尾顶点 (tail), 而v称作该边的终点 (destination) 或头顶点 (head)。

![image-20211209171243090](9.%E5%9B%BE.assets/image-20211209171243090.png)

**度**

对于任何边e $=(u, v)$, 称顶点u和v彼此邻接（adjacent）, 互为邻居：而它们都与边e彼此关联（incident）。在无向图中，与顶点v关联的边数，称作v的度数（degree），记作deg(v)。

对于有向边e $=(u, v)$, e称作u的出边 (outgoing edge) 、v的入边 (incoming edge) 。v的出边总数称作其出度 (out-degree), 记作outdeg(v)；入边总数称作其入度（in-degree），记作indeg(v)。

**简单图**

连接于同一顶点之间的边，称作自环（self-loop）。不含任何自环的图称作简单图。

**道路与环路**

所谓路径或通路（path），就是由m+1个顶点与m条边交替而成的一个序列：
$$
\pi=\left\{v_{0}, e_{1}, v_{1}, e_{2}, v_{2}, \ldots, e_{n}, v_{n}\right\}
$$
也就是说，这些边依次地首尾相连，其中沿途边的总数m，亦称作通路的长度，记作$|\pi|=m$。

为简化描述，也可以依次给出通路沿途的各个顶点，而省略联接于其间的边，即表示为：
$$
\pi=\left\{v_{0}, v_{1}, v_{2}, \ldots, v_{m}\right\}
$$
尽管通路上的边必须互异，但顶点却可能重复。沿途顶点互异的通路，称作简单通路（simple path）。

对于长度 $m \geq 1$ 的通路 $\pi$，若起止顶点相同，则称作环路。不含任何环路的有向图，称作有向无环图（directed acyclic graph，DAG）。除起点、终点外所有顶点均互异的环路称作简单环路。特别地，经过图中各边一次且恰好一次的环路，称作欧拉环路。（Eulerian tour）。对偶地，经过图中各顶点一次且恰好一次地环路，称作哈密顿环路（Hamiltonian tour）。

**带权网络**

图不仅需要表示顶点之间是否存在某种关系，有时还需要表示这一关系的具体细节。为适应这类应用要求，需要通过一个权值函数，为每一边e指定一个权重（weight）。各边均带有权重的图，称作带权图（weighted graph）或带权网络（weighted network），有时也简称为网络（network），记作$G(V, E, w t())$。

**复杂度**

与其它算法一样，图算法也需要就时间性能和空间性能进行分析和比较。相应地，问题的输入规模，也应该以顶点数与边数的总和(n+e)来度量。

无论顶点数多少，边数都可能为0，而至多可能有n(n-1)条边，总而言之，有$e=O\left(n^{2}\right)$。

## 邻接矩阵

邻接矩阵（adjacency matrix）是图最基本的实现方式，使用方阵表示由n个顶点构成的图，其中每个单元各自负责描述一对顶点之间可能存在的邻接关系，故此得名。

![image-20211210004834574](9.%E5%9B%BE.assets/image-20211210004834574.png)

在邻接矩阵中，在内部将所有顶点组织为一个向量`V[]`;同时通过嵌套定义，将所有（潜在的）边组织为一个二维向量`E[][]`，亦即邻接矩阵。

**时间性能**

各顶点的编号可直接转换为其在邻接矩阵中对应的秩, 从而使得 图ADT中所有的静态操作接口, 均只需 $O(1)$ 时间——这主要是得益于向量“循秩访问”的特长与优 势。另外, 边的静态和动态操作也仅需O(1)时间一其代价是邻接矩阵的空间冗余。

然而, 这种方法并非完美无缺。其不足主要体现在, 顶点的动态操作接口均十分耗时。为了 插入新的顶点, 顶点集向量 `V[]` 需要添加一个元素; 边集向量 `E[][]`也需要增加一行, 且每行都需要添加一个元素。顶点删除操作, 亦与此类似。不难看出, 这些恰恰也是向量结构固有的不足。

在通常的算法中，顶点的动态操作远少于其它操作。即便计入向量扩容的代价，就分摊意义而言，单次操作的耗时亦不过$O(n)$。

**空间性能**

邻接矩阵的实现方式所用空间，主要消耗与邻接矩阵。每个Edge对象虽需记录多项信息，但总体不过常数。而Vector结构的装填因子始终不低于50%，故空间总量渐进地不超过$O(n \times n)=O\left(n^{2}\right)$。

对于无向图而言，仍有改进的余地。无向图地邻接矩阵必为对称阵，其中除自环以外的每条边，都被重复地存放了两次。也就是说，近一半的单元都是冗余的。可以用压缩存储等技巧，进一步提高空间利用率。

## 邻接表

即便就有向图而言，$\Theta\left(n^{2}\right)$的空间亦有改进的余地。在实际应用所处理的图，其所含的边通常远远少于$O\left(n^{2}\right)$，比如在平面图之类的稀疏图(sparse graph)中，边数渐进地不超过$O(n)$，仅与顶点总数大致相当。

由此可见，邻接矩阵的空间效率之所以低，是因为其中大量单元所对应的边，通常并未在图中出现。这是因静态空间管理策略导致的问题，故尝试把向量替换为列表。

![image-20211216183400320](9.%E5%9B%BE.assets/image-20211216183400320.png)

可见，邻接表所含列表数等于顶点总数n，每条边在其中仅存放一次（有向图）或两次（无向图），故空间总量为$O(n+e)$，与图自身的规模相当，较之邻接矩阵有很大的改进。

当然, 空间性能的这一改进, 需以某些方面时间性能的降低为代价。比如, 为判断顶点 $v$ 到 u的联边是否存在, exists $(v, u)$ 需在v对应的邻接表中顺序查找, 共需 $O(n)$ 时间。

与顶点相关操作接口, 时间性能依然保持, 甚至有所提高。比如, 顶点的插入操作, 可在 $O(1)$ 而不是 $O(n)$ 时间内完成。当然, 顶点的删除操作, 仍需遍历所有邻接表, 共需O(e)时间。

尽管邻接表访问单条边的效率并不算高, 却十分擅长于以批量方式, 处理同一顶点的所有关联边。在以下图遍历等算法中, 这是典型的处理流程和模式。比如, 为枚举从顶点v发出的所有 边, 现在仅需 $\Theta(1+$ outDegree $(v))$ 而非 $\Theta(n)$ 时间。故总体而言, 邻接表的效率较之邻接矩阵 更高。因此, 对以下各算法的复杂度分析, 多以基于邻接表的实现方式为准。

## 图遍历算法

图遍历算法**对所有顶点和边访问一次且仅一次**，是将图的非线性结构转化为半线性结构（遍历树）的过程。而经遍历而确定的边类型中，最重要的一类即所谓的树边，它们与所有顶点共同构成了原图的一棵支撑树（森林），称为**遍历树 traversal tree**。

图中顶点之间可能存在多条通路，故为避免对顶点的重复访问，在遍历中常要动态地设置各顶点不同的状态，并随着遍历的进程不断转换，直到最后的访问完毕。图的遍历更加强调对于特定状态顶点的甄别与查找，故也称为 **图搜索 graph search**。

深度优先、广度优先、最佳优先等典型图搜索都能在线性时间内完成，若顶点数和边数分别为n和e，则算法的效率即为 O(n+e)，已是最优了。

### 广度优先搜索

各种图搜索之间的区别，体现为边分类结果的不同，以及所得遍历树（森林）的结构差异。其决定因素在于，搜索过程中的每一步迭代，讲依照何种策略来选取下一接受访问的顶点。

图搜索的每一步迭代，通常都是选取某个已访问顶点的邻居。同一顶点的所有连接顶点之间的优先级，在多数遍历中都不讲究，因此实质的差异都体现在，当有多个顶点已被访问过后，应优先从谁的邻居中选取下一个顶点。

**广度优先搜索 breath-first search, BFS** 策略：**越早被访问到的顶点，其邻居越优先被选用**。

过程为先访问图顶点 s，再依次访问 s 所有尚未访问到的邻居;再按后者被访问的先后次序，逐个访问它们的邻居，如此不断。在所有已访问到的顶点中，仍有邻居尚未访问者，构成所谓的 **前沿集 frontier**，于是 BFS 等效为： **反复从波峰集中找到最早被访问到的顶点 v，若其邻居均已访问到，则将其逐出波峰集; 否则随意选出一个尚未访问的邻居，并将其加入到波峰集中**。

类似树的层次遍历，前沿集中顶点的深度始终相差不超过 1，且前沿集总是优先在更浅的层次沿广度方向扩展。

每次迭代都有一个顶点被访问，故至多迭代 O(n)步。因为不会遗漏每个刚被访问顶点的任何邻居，故对于无向图必能覆盖 s 所属的 **连通分量 connected component**，对于有向图必能覆盖以 s  为起点的 **可达分量 reachable component**。

```C++
template <typename Tv, typename Te> //广度优先搜索 BFS 算法（全图）
void Graph<Tv, Te>::bfs(int s) { //assert: 0 <= s < n
    //初始化
    reset();
    int clock = 0;
    int v = s; 

    do //逐一检查所有顶点
        if (UNDISCOVERED == status(v) ) //一旦遇到尚未发现的顶点
            BFS(v, clock); //即从该顶点出发启动一次 BFS
    while ( s != (v=(++v%n)) ); //按序号检查，故不漏不重
}

template <typename Tv, typename Te> //广度优先搜索 BFS 算法（单个连通域）
void Graph<Tv, Te>::BFS(int v, int& clock) { //assert: 0 <= v < n
    Queue<int> Q; //引入辅助队列

    status(v) = DISCOVERED; Q.enqueue(v); //初始化起点

    while(!Q.empty()) {
        int v = Q.dequeue();
        dTime(v) == ++clock; //取出队首顶点 v
        for (int u=firstNbr(v); -1<u; u=nextNbr(v, u)) //枚举 v 的所有邻居 u
            if (UNDISCOVERED == status(u)) { //若 u 尚未被发现，则
                status(u) == DISCOVERED; Q.enqueue(u); //发现该顶点
                type(v, u) = TREE; parent(u) = v; //引入树边拓展支撑树
            } else { //若 u 已被发现，或者甚至已访问完成，则
                type(v, u) = CROSS; //将 (v, u) 归类于跨边
            }

        status(v) = VISITED; //至此，当前顶点访问完毕
    }
}
```

算法的实质功能， 由子算法BFS()完成。对该函数的反复调用，即可遍历所有连通或可达域。

仿照树的层次遍历，这里也借助队列Q，来保存已被发现， 但尚未访问完毕的顶点。 因此，任何顶点在进入该队列的同时，都被随即标记为DISCOVERED（已发现）状态。

BFS()的每一步迭代， 都先从Q中取出当前的首顶点v；再逐一核对其各邻居u的状态并做相应处理；最后将顶点v置为VISITED（访问完毕）状态，即可进入下一步迭代。

若顶点u尚处于UNDISCOVERED（未发现）状态， 则令其转为DISCOVERED状态， 并随即加入队列Q。实际上， 每次发现一个这样的顶点u，都意味着遍历树可从v到u拓展一条边。 于是， 将边(v, u)标记为树边（tree edge） ，并按照遍历树中的承袭关系， 将v记作u的父节点。

若顶点u已处于DISCOVERED状态（无向图），或者甚至处于VISITED状态（有向图） ，则意味着边(v, u)不属于遍历树，于是将该边归类为跨边（cross edge） 。

BFS()遍历结束后，所有访问过的顶点通过parent[]指针依次联接，从整体上给出了原图某一连通或可达域的一棵遍历树，称作广度优先搜索树， 或简称BFS树（BFS tree） 。  

下图给出了一个含8个顶点和11条边的有向图，起始于顶点S的BFS搜索过程。

![image-20211216233754436](9.%E5%9B%BE.assets/image-20211216233754436.png)

不难看出，BFS(s)将覆盖起始顶点s所属的连通分量或可达分量，但无法抵达此外的顶点。而上层主函数bfs()的作用，正在于处理多个连通分量或可达分量并存的情况。如此，各次BFS()调用所得的BFS树构成一个森林，称作BFS森林(BFS forest).

复杂度：除作为输入的图本身以外，BFS搜索所使用的空间，主要消耗在于维护顶点访问次序的辅助队列、用于记录顶点和边状态的标识向量，累计O(n)+O(n)+O(e) = O(n + e)。时间方面，首先需花费O(n+e)时间复位所有顶点和边的状态，不计对子函数BFS()的调用，bfs()本身对所有顶点的枚举共需O(n)时间，而在对BFS()的所有调用中，每个顶点、每条边均只耗费O(1)时间，累计O(n+e)。故综合起来，BFS搜索总体仅需O(n+e)时间。

> 邻接表形式存储时，每个顶点均需搜索一次，时间复杂度T1=O（v），从一个顶点开始搜索时，开始搜索，访问未被访问过的节点。最坏的情况下，每个顶点至少访问一次，每条边至少访问1次，这是因为在搜索的过程中，若某结点向下搜索时，其子结点都访问过了，这时候就会回退，故时间复 杂度为O(E)，算法总的时间复 度为O(|V|+|E|)。
>
> 邻接矩阵存储方式时，查找每个顶点的邻接点所需时间为O(V)，即该节点所在的该行该列。又有n个顶点，故算总的时间复杂度为O(|V|^2)。

### 深度优先搜索

深度优先搜索(Depth-First Search,DFS)选取下一顶点的策略，可概括为：**优先选取最后一个被访问到的顶点的邻居。**

各顶点被访问到的次序，类似于树的先序遍历; 而各顶点被访问完毕的次序，则类似于树的后序遍历，从内到外一个个环遍历。

```C++
template <typename Tv, typename Te> //深度优先搜索 DFS 算法（全图）
void Graph<Tv, Te>::dfs(int s) { //assert: 0 <= s < n
    //初始化
    reset();
    int clock = 0;
    int v = s; 

    do //逐一检查所有顶点
        if (UNDISCOVERED == status(v) ) //一旦遇到尚未发现的顶点
            DFS(v, clock); //即从该顶点出发启动一次 DFS
    while ( s != (v=(++v%n)) ); //按序号检查，故不漏不重
}

template <typename Tv, typename Te> //深度优先搜索 DFS 算法（单个连通域）
void Graph<Tv, Te>::DFS(int v, int& clock) { //assert: 0 <= v < n
    dTime(v) = ++clock; //发现时间
    status(v) = DISCOVERED; //发现当前顶点 v

    for (int u=firstNbr(v); -1<u; u=nextNbr(v, u)) //枚举 v 的所有邻居 u
       
        /并视其状态分别处理
            case UNDISCOVERED: //u 尚未发现，意味着支撑树可在此拓展
                type(v, u) = TREE;
                parent(u) = v;
                DFS(u, clock);
                break;
            case DISCOVERED: //u 已被发现但尚未访问完毕，此处有一个有向环路，应属被后代指向的祖先                            
                type(v, u) = BACKWARD;
                break;
            default: //u 已访问完毕(VISITED, 有向图)，则视承袭关系分为前向边或跨边，
                     // 比对活跃期，判定在 DFS 树中 v 是否为 u 祖先，若是，则边 (v,u) 是前向边，否则
                     // 二者必然来自相互独立的两个分支，边 (v,u) 应归类为跨边 CROSS
                type(v, u) = ( dTime(v) < dTime(u) ) ? FORWARD : CROSS;
                break;
        }

    status(v) = VISITED; //至此，当前顶点 v 方告访问完毕
    fTime(v) = ++clock; // 完毕时间
}
```

在每一递归实例中，都先将当前节点v标记为DISCOVERED状态，再逐一核对其各邻居u的状态并做相应处理。待其所有邻居均处理完毕之后，将顶点v置为VISTIED（访问完毕）状态，便可回溯。

若顶点u尚处于UNDISCOVERED（未发现）状态，则将边（v，u)归类为归类为树边（tree edge），并将v记作u的父节点。此后，便可将u作为当前顶点，继续递归地遍历。

若顶点u处于DISCOVERED状态，则意味着在此处发现一个有向环路。此时， 在DFS遍历树中u必为v的祖先，故应将边(v, u)归类为后向边（back edge） 。

这里为每个顶点 v 都记录了被发现的时刻 dTime 和访问完毕的时刻 fTime，对应的区间 [dTime(v), fTime(v)] 称为 v 的活跃期 **active duration**。 实际上，任意顶点 v 和 u 间是否存在祖先/后代关系，完全取决于二者的活跃期是否相互包含。

对于有向图，顶点u还可能处于VISITED状态。此时， 只要比对v与u的活跃期，即可判定在DFS树中v是否为u的祖先。若是，则边(v, u)应归类为前向边（forward edge） ；否则，二者必然来自相互独立的两个分支，边(v, u)应归类为跨边（cross edge） 。

DFS(s)返回后，所有访问过的顶点通过parent[]指针依次联接，从整体上给出了顶点s所属连通或可达分量的一棵遍历树，称作深度优先搜索树或DFS树（DFS tree） 。与BFS搜索一样，此时若还有其它的连通或可达分量，则可以其中任何顶点为基点， 再次启动DFS搜索。最终， 经各次DFS搜索生成的一系列DFS树， 构成了DFS森林（DFS forest） 。  

下图根据7个顶点和10条边地某有向图，给出了DFS搜索的详细过程：

![image-20211218000552023](9.%E5%9B%BE.assets/image-20211218000552023.png)

![image-20211218000601656](9.%E5%9B%BE.assets/image-20211218000601656.png)

由上可以看出，选用不同的起始基点，生成的DFS树（森林）也可能各异。

可以以时间为横坐标，绘出DFS树内各顶点的活跃期：

![image-20211218000851964](9.%E5%9B%BE.assets/image-20211218000851964.png)

可以清晰地看出，活跃期相互包含的顶点，在DFS树中都是祖先-后代关系。这种对应关系并非偶然，藉此可以便捷地划定节点之间的承袭关系。故无论是对DFS搜索本身，还是对基于DFS的各种算法而言，时间标签都至关重要。

复杂度：

空间上：各顶点的时间标签和状态标记，以边各边的分类标记，为 O(n)+O(e)=O(n+e)。当然，如果采用直接递归的实现方式，操作系统为了维护运行栈还需要耗费一定量的空间——尽管这部分增量在渐进意义下还不足以动摇以上结论，为此，可以显式地引入并维护一个栈结构，将DFS算法改写为迭代版本。

时间复杂度为 O(n+e)。

### 拓扑排序

![image-20211218002246610](9.%E5%9B%BE.assets/image-20211218002246610.png)

有向无环图：

![image-20211218002548517](9.%E5%9B%BE.assets/image-20211218002548517.png)

以上是拓扑排序算法的一个实例，以下将转而从DFS搜索入手，给出另一拓扑排序算法。

不妨将关注点， 转至与极大顶点相对称的极小顶点。

同理，有限偏序集中也必然存在极小元素（同样，未必唯一）。该元素作为顶点， 出度必然为零，而在对有向无环图的DFS搜索中，首先因访问完成而转换至VISITED状态的顶点m， 也必然具有这一性质；反之亦然。

进一步地， 根据DFS搜索的特性，顶点m（及其关联边）对此后的搜索过程将不起任何作用。于是，下一转换至VISITED状态的顶点可等效地理解为是，从图中剔除顶点m（及其关联边）之后的出度为零者——在拓扑排序中，该顶点应为顶点m的前驱。由此可见， DFS搜索过程中各顶点被标记为VISITED的次序，恰好（按逆序）给出了原图的一个拓扑排序。此外， DFS搜索善于检测环路的特性，恰好可以用来判别输入是否为有向无环图。具体地，搜索过程中一旦发现后向边，即可终止算法并报告“因非DAG而无法拓扑排序” 。

```C++
template <typename Tv, typename Te> //基于 DFS 的拓扑排序算法
Stack<Tv>* Graph<Tv, Te>::tSort_DFS(int s) { //assert: 0 <= s < n
    reset();
    int clock = 0;
    int v = s;
    Stack<Tv>* S = new Stack<Tv>; //用栈记录排序顶点

    do {
        if (UNDISCOVERED == status(v))
            if (!TSort_DFS(v, clock, S)) { // clock 并非必需
                while (!S->empty()) //任一连通域（亦即整图）非 DAG，则不必继续计算，直接返回
                    S->pop();
                break;
            }
    } while (s != (v=(++v % n)));

    return S; //若输入为 DAG，则 S 内各顶点自顶向底排序; 否则（不存在拓扑排序），为空
}

template <typename Tv, typename Te> //基于 DFS 的拓扑排序算法（单趟）
bool Graph<Tv, Te>::TSort_DFS(int v, int& clock, Stack<Tv>* S) { //assert: 0 <= v < n
    dTime = ++clock;
    status(v) = DISCOVERED; //发现顶点 v
    for (int u=firstNbr(v); -1 < u; u = nextNbr(v, u)) //枚举 v 所有邻居 u
        switch(status(u)) { //并视 u 的状态分别处理
            case UNDISCOVERED:
                parent(u) = v;
                status(v, u) = TREE;
                if (!TSort_DFS(u, clock, S)) //从顶点 u 处出发深入搜索
                    return false; //若 u 及其后代不能拓扑排序（则全图也如此）
                break;
            case DISCOVERED:
                status(v, u) = BACKWARD; //一旦发现后向边（非 DAG），则
                return false; //不必深入
            default: //VISITED (digraphs only)
                status(v, u) = (dTime(v) < dTime(u)) ? FORWARD : CROSS;
                break;
        }

    status(v) = VISITED;
    S->push(vertex(v)); //顶点被标记为 VISITED; 并入栈
    return true; //v 及后代可拓扑排序

```

相对于标准的DFS搜索算法， 这里增设了一个栈结构。 一旦某个顶点被标记为VISITED状态，便随即令其入栈。如此，当搜索终止时，所有顶点即按照被访问完毕的次序——亦即拓扑排序的次序——在栈中自顶而下排列。  

![image-20211218003421350](9.%E5%9B%BE.assets/image-20211218003421350.png)

因为多个极大、极小元素（入度、出度为零顶点）并存而导致拓扑排序的不唯一性并未消除，而是转由该算法对每趟DFS起点的选择策略决定。

### 双连通域分解

对于无向图G来说，若删除顶点v后G所包含的连通域增多，则把v称为切割节点（cut vertex）或关节点（articulation point）。不含任何关节点的图称作双连通图。任一无向图都可视作若干个极大的双连通子图组合而成，这样的每一子图都称作原图的一个双连通域（bi-connected component）。

![image-20211218172715163](9.%E5%9B%BE.assets/image-20211218172715163.png)

较之其它顶点，关节点更为重要。找出关节点并重点予以保障，是提高系统整体稳定性和鲁棒性的基本策略。

蛮力算法：通过BFS或DFS搜索统计出图G所含连通域的数目；然后逐一枚举每个顶点v，暂时将其从图G中删去，并再次通过搜索统计出图G\{v}所含连通域的数目。 于是， 顶点v是关节点，当且仅当图`G\{v}`包含的连通域多于图G。这一算法需执行n趟搜索，耗时O(n(n+e))，如此低的效率无法令人满意。

可行算法：

![image-20211218174126313](9.%E5%9B%BE.assets/image-20211218174126313.png)

```C++
template <typename Tv, typename Te>
void Graph<Tv, Te>::bcc(int s) { //基于 DFS 的 BCC 分解算法
    reset();
    int clock = 0;
    int v = s;
    Stack<int> S; //栈 S 用于记录已访问的顶点

    do 
        if (UNDISCOVERED == status(v)) { //一旦找到有未发现的顶点（新连通分量）
            BCC( v, clock, S); //即从该顶点出发启动一次 BCC
            S.pop(); //遍历返回后，弹出栈中最后一个顶点---当前连通域的起点
        }
    while ( s != (v=(++v % n)) );
}

#define hca(x) (fTime(x)) //利用此处闲置的 fTime[] 充当 hca[]

template <typename Tv, typename Te>
void Graph<Tv, Te>::BCC(int v, int& clock, Stack<int>& S) {
    hca(v) = dTime(v) = ++clock;
    status(v) = DISCOVERED;
    S.push(v); // v 被发现并入栈
    for (int u = firstNbr(v); -1 < u; u = nextNbr(v, u)) //枚举 v  的所有邻居 u
        switch( status(u) ) { //并视 u 的状态分别处理
            case UNDISCOVERED:
                parent(u) = v;
                type(v, u) = TREE;
                BCC(u, clock, S); //从顶点 u 处深入

                if (hca(u) < dTime(v)) //遍历返回后，若发现 u（通过后向边）可指向 v 的真祖先。逐一这里能这样判断的条件是下边DISCOVERED状态的时间更新
                    hca(v) = min(hca(v), hca(u)); //则 v 亦必如此
                else { //否则，以 v 为关节点（u 以下即是一个 BCC，且其中顶点此时正集中于栈 S 的顶部）
                    while ( v != S.pop() ) //依次弹出当前 BCC 中的节点，亦可根据实际需求转存至其它结构
                        /*pass*/;
                    S.push(v); //最后一个顶点（关节点）重新入栈---总计至多两次
                }
                break;
            case DISCOVERED:
                type(v, u) = BACKWARD; //标记(v, u), 并按照 “越小越高” 的准则
                if (u != parent(v))
                    hca(v) = min(hca(v), dTime(u)); //更新 hca[v]
                break;
            default: //VISITED（有向图）
                type(v, u) = (dTime(v) < dTime(u)) ? FORWARD:CROSS;
                break;
        }
    status(v) = VISITED; //对 v 的访问结束
}

#undef hca
```

每遇到一条后向边(v, u)，也需要及时地将hca[v]， 更新为hca[v]与dTime[u]之
间的更小者，以保证hca[v]能够始终记录顶点v可经由后向边向上连通的最高祖先。  

![image-20211218180447679](9.%E5%9B%BE.assets/image-20211218180447679.png)

![image-20211218180459431](9.%E5%9B%BE.assets/image-20211218180459431.png)

> 注意图示中的栈，栈中实际上存放的还是顶点，写成“边”的形式只是为了便于理解！

复杂度：与基本的DFS搜索算法相比，这里只增加了一个O(n)的辅助栈，故整体空间复杂度仍为O(n + e)  。时间方面，尽管同一顶点v可能多次入栈，但每一次重复入栈都对应于某一新发现的双连通域，与之对应地必有至少另一顶点出栈且不再入栈，因此，这类重复入栈操作不会超过n次，入栈操作累计不超过2n次，故算法的整体运行时间依然是O(n + e)。

### 优先级搜索

以上图搜索算法在功能上的差异，主要体现为每一步迭代中对新顶点的选取策略不同。每一种选取策略都等效于，给所有顶点赋予不同的优先级，而且随着算法的不断推进调整；每一步迭代所选取的顶点，都是当时的优先级最高者。按照这种理解，包括BFS和DFS在内的几乎所有图搜索，都可纳入统一的框架，鉴于优先级在其中所扮演的关键角色，称作优先级搜索（priority-first search, PFS), 或最佳优先搜索（best-first search， BFS）。

在实际应用中， 引导优化方向的指标， 往往对应于某种有限的资源或成本（如光纤长度、通讯带宽、 机票价格等）， 故这里不妨约定优先级数越大（小）顶点的优先级越低（高）。相应地，在算法的初始化阶段，通常都将顶点的优先级数统一置为最大（比如对于int类型，可采用INT_MAX），或等价地，优先级最低。  

```C++
template <typename Tv, typename Te> template <typename PU> //优先级搜索（全图）
void Graph<Tv, Te>::pfs( int s, PU prioUpdate){ //assert: 0 <= s < n
    reset(); int v = s; //初始化

    do //逐一检查所有顶点
        if (UNDISCOVERED == status(v)) //一旦遇到尚未发现的顶点
            PFS(v, prioUpdate); //即从该顶点出发启动一次 PFS
    while (s != (v=(++v % n))); //按序号检查，故不漏不重
}

template <typename Tv, typename Te> template <typename PU> //顶点，边，优先级更新器
void Graph<Tv, Te>::PFS(int v, PU prioUpdate){ //优先级搜索（单个连通域）
    //初始化
    priority(v) = 0;
    status(v) = VISITED;
    parent(v) = -1; //起点 v 加至 PFS 树中

    while(1) { //将下一顶点和边加至 PFS 树中
        for (int u=firstNbr(v); -1<u; u=nextNbr(v,u)) //枚举 v 的所有邻居
            prioUpdate(this, v, u); //更新顶点 u 的优先级及其父顶点

        //从尚未加入遍历树的顶点中选出一个优先级最高的顶点 v
        for (int shortest = INT_MAX, u=0; u<n; u++) //n 为顶点总数，注意这里u要遍历所有顶点！而不是只有当前的顶点的邻居！
            if (UNDISCOVERED == status(u))
                if (shortest > priority(u)) {
                    shortest = priority(u);
                    v = u;
                }

        if (VISITED == status(v)) //直到所有顶点均已加入
            break;

        status(v) = VISITED; //将 v 及其父的联边加入遍历树
        type(parent(v), v) = TREE;
    }
} //通过定义具体的优先级更新策略prioUpdate, 即可实现不同的算法功能
```

可见， PFS搜索的基本过程和功能与常规的图搜索算法一样，也是以迭代方式逐步引入顶点和边，最终构造出一棵遍历树（或者遍历森林） 。如上所述，每次都是引入当前优先级最高（优先级数最小）的顶点s，然后按照不同的策略更新其邻接顶点的优先级数。  

这里借助函数对象prioUpdater，使算法设计者得以根据不同的问题需求，简明地描述和实现对应的更新策略。 具体地，只需重新定义prioUpdater对象即可，而不必重复实现公共部分。 

 PFS搜索由两重循环构成，其中内层循环又含并列的两个循环，若采用邻接表实现方式，同时假定prioUpdater（）只需常数时间，则前一内循环的累计时间应取决于所有顶点的出度总和，  即O(e)； 后一内循环固定迭代n次，累计$O\left(n^{2}\right)$时间。两项合计总体复杂度为$O\left(n^{2}\right)$。

## 最小支撑树

![image-20211218184730824](9.%E5%9B%BE.assets/image-20211218184730824.png)

若图G为一带权网络，则每一棵支撑树的成本(cost)即为其所采用各边权重的总和，在G所有支撑树中，成本最低者称作最小支撑树（minimum spanning tree）。聚类分析、网络架构设计等问题，都可转化并描述为最小支撑树的构造问题。

![image-20211218185927792](9.%E5%9B%BE.assets/image-20211218185927792.png)

蛮力算法：由最小支撑树的定义，可直接导出蛮力算法大致如下：逐一考查G的所有支撑树并统计其成本， 从而挑选出其中的最低者。然而根据Cayley公式，由n个互异顶点组成的完全图共有$n^{n-2}$棵支撑树， 即便忽略掉构造所有支撑树所需的成本，仅为更新最低成本的记录就需要O($n^{n-2}$)时间。  



> **Prüfer**序列与Caylay算法：
>
> 一棵树要得到普吕弗序列，方法是逐次去掉树的顶点，直到剩下两个顶点。考虑树T，其顶点为{1, 2, ..., n}。在第i步，去掉标号最小的叶，并把普吕弗序列的第i项设为这叶的邻顶点的标号。
>
> 一棵树的序列明显是唯一的，而且长为n − 2。
>
> 把上述算法用在下图标号树。第一步，顶点1是最小标号的叶，因此首先去掉，普吕弗序列首项是"4"，接着去掉顶点2和3，"4"两次加进序列。顶点4现在是叶，去掉后剩下2个顶点，所以把"5"加进序列后结束。树的序列是{4,4,4,5}。
>
> ![img](9.%E5%9B%BE.assets/162px-Tree_graph.svg.png)
>
> 从一个普吕弗序列，可以求得一棵树有这一普吕弗序列。
>
> 设这普吕弗序列长n − 2。首先写出数1至n。第一步，找出1至n中没有在序列中出现的最小数。把标号为这数的顶点和标号为序列首项的顶点连起来，并把这数从1至n中删去，序列的首项也删去。接着每一步以1至n中剩下的数和余下序列重复以上步骤。最后当序列用完，把1至n中最后剩下的两数的顶点连起来。
>
> 从这结果立刻可知，普吕弗序列给出长n−2的序列和有n顶点的标号树之间的一一映射。长n−2的序列共有$n^{n-2}$个，这样就证明了凯莱公式，就是n顶点的标号树共有$n^{n-2}$棵。

Prim算法：

![image-20211218191553993](9.%E5%9B%BE.assets/image-20211218191553993.png)

由以上性质，可基于贪心策略导出一个迭代式算法。基于贪心算法：每步迭代前，假设已得到最小支撑树 T 的一棵子树 $T_k = (V_k; E_K)$，其中 $V_k$ 含 k 个顶点， $E_K$ 含 $k-1$ 条边。若将 $V_K$ 及其补集视作一个割，则在找到该割的最短跨越边 $e_k$ 后，可将 $T_k$ 扩展为一棵更大的子树 $T_{k+1}$。而迭代基 $T_1$ 为不含边的单个顶点，可在原图中任意选取。

![image-20211218191742548](9.%E5%9B%BE.assets/image-20211218191742548.png)

```C++
template <typename Tv, typename Te> struct PrimPU { //针对 Prim 算法的顶点优先级更新器
    virtual void operator() (Graph<Tv, Te>* g, int v, int u) {
        if (UNDISCOVERED == g->status(u)) //对于 v 的每一尚未发现的邻接顶点 u
            if (g->priority(u) > g->weight(v, u)) { //按 Prim 策略做松弛
                g->priority(u) = g->weight(v, u); //更新优先级（数）
                g->parent(u) = v; //更新父节点
            }
    }
};
```

每次由$\mathrm{T}_{\mathrm{k}}$ 扩充至 $\mathrm{T}_{\mathrm{k}+1}$时，都可以将$V_{k}$ 之外每个顶点 $u$ 到 $V_{k}$ 的距离视作 $u$ 的优先级数。如此, 每一最短跨越边 $e_{k}$ 对应的顶点$u_{k}$ 都会因拥有最小的优先级数 (即最高的优先级) 而自然地被选中。那么, $u_{k}$ 和 $e_{k}$ 加入 $T_{k}$ 之后, 应如何快速更新 $V_{k+1}$ 以外顶点的优先级数呢? 实际上, 与 $u_{k}$ 互不 关联的顶点都无需考虑, 故只需遍历 $u_{k}$ 的每一邻居 $v$, 若边 $u_{k} v$ 的权重小于 $v$ 当前的优先级数, 则将后者更新为前者。

## 最短路径

若以带权图来表示真实的通讯、交通、物流或社交网络，则各边的权重可能代表信道成本，交通运输费用或交往程度。这类问题可以概括为：给定带权网络G=(V,E),以及源点(source)，对于所有其它顶点v，s到v的最短通路有多长，该通路由哪些边构成。

![image-20211219121041497](9.%E5%9B%BE.assets/image-20211219121041497.png)

Dijkstra算法：

![image-20211219122156591](9.%E5%9B%BE.assets/image-20211219122156591.png)

![image-20211219122338204](9.%E5%9B%BE.assets/image-20211219122338204.png)

与Prim算法一样，Dijkstra算法也可纳入此前的优先级搜索框架。为此，每次由$\mathrm{T}_{k}$ 扩展至 $\mathrm{T}_{k+1}$ 时，可将$\mathrm{V}_{\mathrm{k}}$ 之外各顶点 $\mathrm{u}$ 到 $\mathrm{V}_{\mathrm{k}}$ 的距离看作 $\mathrm{u}$ 的优先级数（若u与Vk内顶点均无连边，则优先级数设为$\infty$，如此，每一最短跨越边$\mathrm{e}_{\mathrm{k}}$ 所对应的顶点 $\mathrm{u}_{\mathrm{k}}$，都会因为拥有最小的优先级数（或等价地，最高的优先级）而被选中。

```C++
template <typename Tv, typename Te> struct DijkstraPU { //针对 Dijkstra 算法的顶点优先级更新器
    virtual void operator() (Graph<Tv, Te>* g, int v, int u){
        if (UNDISCOVERED == g->status(u)) //对于 v 每一尚未被发现的邻接顶点 u, 按 Dijkstra 策略
            if (g->priority(u) > g->priority(v)+g->weight(v,u)) { //做松弛
                g->priority(u) = g->priority(v) + g->weight(v, u); //更新优先级（数）
                g->parent(u) = v; //并同时更新父节点
            }
    }
};
```

![image-20211219122824885](9.%E5%9B%BE.assets/image-20211219122824885.png)

不难看出，以上顶点优先级更新器只需要常数运行时间，Dijkstra算法这一实现版本的时间复杂度为$O\left(n^{2}\right)$。作为PFS搜索的特例，Dijkstra算法这一实现版本的时间复杂度为$O\left(n^{2}\right)$，而作为PFS搜索的特例，Dijkstra算法的效率也可以借助优先级队列进一步提高。
