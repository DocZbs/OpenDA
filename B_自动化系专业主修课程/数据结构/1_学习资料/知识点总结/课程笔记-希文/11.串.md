串或字符串(string)属于线性结构，自然地可以利用向量或列表等序列结构加以实现，但是字符串作为一种数据结构，特点及其鲜明。但是，作为字符串基本组成元素的字符，种类通常不多。鉴于字符串上述特点，我们可以设计专门的处理方法，并将重点聚焦于串匹配算法的设计、实现与优化。在此类应用中，更多地是以某一局部字串为单位，考察其对应的模式(pattern)，因此也被称作循模式访问（call-by-pattern)。

## 串及串匹配

### 串

![image-20220101154258516](11.%E4%B8%B2.assets/image-20220101154258516.png)

![image-20220101154316835](11.%E4%B8%B2.assets/image-20220101154316835.png)

### 串匹配

在涉及字符串的众多实际应用中，模式匹配是最常使用的一项基本操作，比如UNIX Shell的grep操作，基本功能是在指定的字符串中查找特定模式的字符串。

![image-20220101154519044](11.%E4%B8%B2.assets/image-20220101154519044.png)

![image-20220101154628674](11.%E4%B8%B2.assets/image-20220101154628674.png)

### 蛮力算法

![image-20220101155404755](11.%E4%B8%B2.assets/image-20220101155404755.png)

![image-20220101155457934](11.%E4%B8%B2.assets/image-20220101155457934.png)

![image-20220101155608587](11.%E4%B8%B2.assets/image-20220101155608587.png)

![image-20220101155658119](11.%E4%B8%B2.assets/image-20220101155658119.png)

### KMP算法

![image-20220101160526942](11.%E4%B8%B2.assets/image-20220101160526942.png)

> 算法的改进点：利用以往信息实现大跨度的移动。

![image-20220101160843147](11.%E4%B8%B2.assets/image-20220101160843147.png)

> 注意，这个next表仅跟模式串有关，而与文本串无关。
>
> 理解next表的关键：一旦发现P[j]与T[i]失配，即可转而将P[next[j]]与T[i]彼此对准。

![image-20220101161514215](11.%E4%B8%B2.assets/image-20220101161514215.png)

> 中间显著的不同：文本串不用回退！

快速构建next表，是KMP算法的精髓所在，核心思想是“**P自己与自己做匹配**”。

![image-20220101162315711](11.%E4%B8%B2.assets/image-20220101162315711.png)

![image-20220101164431903](11.%E4%B8%B2.assets/image-20220101164431903.png)

> 注意这里的区间都是开区间！

![image-20220101164705837](11.%E4%B8%B2.assets/image-20220101164705837.png)

这里寻找next[j+1]的过程，实际上就是为了寻找在左闭右开区间内最大公共子串的长度，而观察，这正是next[j]的意义！

![image-20220101164836654](11.%E4%B8%B2.assets/image-20220101164836654.png)

![image-20220101170422537](11.%E4%B8%B2.assets/image-20220101170422537.png)

![image-20220101170523291](11.%E4%B8%B2.assets/image-20220101170523291.png)

![image-20220101170737859](11.%E4%B8%B2.assets/image-20220101170737859.png)

![image-20220101170746919](11.%E4%B8%B2.assets/image-20220101170746919.png)

### BM算法

![image-20220101170915452](11.%E4%B8%B2.assets/image-20220101170915452.png)

![image-20220101171349076](11.%E4%B8%B2.assets/image-20220101171349076.png)

![image-20220101171403839](11.%E4%B8%B2.assets/image-20220101171403839.png)

![image-20220101171437881](11.%E4%B8%B2.assets/image-20220101171437881.png)

![image-20220101171501598](11.%E4%B8%B2.assets/image-20220101171501598.png)

![image-20220101171731647](11.%E4%B8%B2.assets/image-20220101171731647.png)

![image-20220101171753150](11.%E4%B8%B2.assets/image-20220101171753150.png)

![image-20220101172611861](11.%E4%B8%B2.assets/image-20220101172611861.png)

![image-20220101172720388](11.%E4%B8%B2.assets/image-20220101172720388.png)

![image-20220101173018488](11.%E4%B8%B2.assets/image-20220101173018488.png)

![image-20220101173038534](11.%E4%B8%B2.assets/image-20220101173038534.png)

![image-20220101173333778](11.%E4%B8%B2.assets/image-20220101173333778.png)

![image-20220101173514810](11.%E4%B8%B2.assets/image-20220101173514810.png)

![image-20220101173526893](11.%E4%B8%B2.assets/image-20220101173526893.png)

![image-20220101173755094](11.%E4%B8%B2.assets/image-20220101173755094.png)

![image-20220101173803597](11.%E4%B8%B2.assets/image-20220101173803597.png)

![image-20220101173813437](11.%E4%B8%B2.assets/image-20220101173813437.png)

![image-20220101173821175](11.%E4%B8%B2.assets/image-20220101173821175.png)

![image-20220101173829408](11.%E4%B8%B2.assets/image-20220101173829408.png)

![image-20220101173852869](11.%E4%B8%B2.assets/image-20220101173852869.png)

### Karp-Rabin算法

