此前的搜索树结构和词典结构，都支持盖数据全集的访问和操作。也就是说，其中存储的每一数据对象都可作为查找和访问目标。 为此，搜索树结构需要在所有元素之间定义并维护一个显式的全序（full order） 关系；而词典结构中的数据对象之间， 尽管不必支持比较大小，但在散列表之类的具体实现中，都从内部强制地在对象的数值与其对应的秩之间， 建立起某种关联（尽管实际上这种关联通常越“随机”越好） ，从而隐式地定义了一个全序次序。

而优先级队列则将操作对象限于当前的全局极值者。这种根据数据对象之间相对优先级对其进行访问的方式，与此前的访问方式有着本质区别，称作循优先级访问（call-by-priority）。

当然， “全局极值” 本身就隐含了“所有元素可相互比较” 这一性质。然而，优先级队列并不会也不必忠实地动态维护这个全序，却转而维护一个偏序（partial order） 关系。 其高明之处在于，如此不仅足以高效地支持仅针对极值对象的接口操作， 更可有效地控制整体计算成本。正如我们将要看到的， 对于常规的查找、插入或删除等操作，优先级队列的效率并不低于此前的结构；而对于数据集的批量构建及相互合并等操作，其性能却更胜一筹。 作为不失高效率的轻量级数据结构，优先级队列在许多领域都是扮演着不可替代的角色。  

## 优先级队列ADT

优先级队列的思想在很多数据结构和算法设计中都得以体现，如在选择排序算法中，每一步迭代都要调用selectMax（）函数，从未排序区间中选出最大者。而在Huffman编码算法中，每一步迭代都要调用minHChar（），从当前的森林中选出权重最小的超字符。在基于空间扫描策略的各种算法中，每一步迭代都要根据到当前扫描线的距离，取出并处理最近的下一个事件点。

从数据结构的角度看，无论是排序节点的数值、超字符的权重，还是事件的发生时间，数据项的某种属性只要可以相互比较大小，则这种大小关系即可称作优先级（priority）。而按照事先约定的优先级，可以始终高效查找并访问优先级最高数据项的数据结构，也统称作优先级队列（priority queue).

![image-20220101141715535](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101141715535.png)

![image-20220101141736249](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101141736249.png)

在清楚优先级队列的ADT接口后，我们可以基于优先级队列描述和实现各种算法：

选择排序：将待排序的词条组织为一个优先级队列，然后反复调用delMax()接口，即可按关键码由大到小的次序逐一输出所有词条，从而得到全体词条的排序序列

![image-20220101141954266](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101141954266.png)

![image-20220101142006446](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101142006446.png)

应用实例：Huffman编码树

![image-20220101142048920](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101142048920.png)

![image-20220101142156637](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101142156637.png)

## 堆

基于列表或向量等结构的实现方式，之所以无法同时保证insert()和delMax()操作的高效率，原因在于其对优先级的理解过于机械，以致始终都保存了全体词条之间的全序关系。实际上，尽管优先级队列的确隐含了“所有词条可相互比较”这一条件，但从操作接口层面来看，并不需要真正地维护全序关系。

有限偏序集的极值必然存在，故此时借助堆（heap）结构维护一个偏序关系即足矣。堆有多种实现形式，以下首先介绍其中最基本的一种形式——完全二叉堆(complete binary heap).

### 完全二叉堆

![image-20220101143410862](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101143410862.png)

> 堆序性：堆顶以外的每个节点都不低（小）于父节点，反之同理。

![image-20220101143933929](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101143933929.png)

![image-20220101144212434](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101144212434.png)

![image-20220101145807701](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101145807701.png)

### 元素插入

![image-20220101144810856](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101144810856.png)

![image-20220101144927358](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101144927358.png)

上滤调整后只需将两个节点交换即可，这正是因为堆结构只需要维护一个偏序性，而不是全序性，只要满足堆序性的要求即可。

![image-20220101145723858](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101145723858.png)

![image-20220101145852731](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101145852731.png)

### 元素删除

![image-20220101150158395](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101150158395.png)

![image-20220101150211086](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101150211086.png)

![image-20220101150227173](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101150227173.png)

### 建堆

![tmpEBCB](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/tmpEBCB.png)

![image-20220101150501734](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101150501734.png)

![image-20220101150718768](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101150718768.png)

![image-20220101150829718](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101150829718.png)

![image-20220101150843621](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101150843621.png)

### 就地堆排序

![image-20220101151013297](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101151013297.png)

![image-20220101151120865](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101151120865.png)

## 左式堆

### 堆合并

![image-20220101151404580](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101151404580.png)

### 单侧倾斜

![image-20220101151658276](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101151658276.png)

### 空节点路径长度

![image-20220101152041171](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101152041171.png)

### 左倾性与左式堆

![image-20220101152140907](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101152140907.png)

### 最右侧通路

![image-20220101152227957](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101152227957.png)

### 合并算法

![image-20220101152425121](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101152425121.png)

![image-20220101152955075](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101152955075.png)

![image-20220101153005533](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101153005533.png)

> 这实质上是一个递归算法！

![image-20220101153029948](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101153029948.png)

![image-20220101153317032](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101153317032.png)

**基于合并的插入和删除：**

![image-20220101153430591](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101153430591.png)

![image-20220101153445767](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101153445767.png)

![image-20220101153456360](8.%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97.assets/image-20220101153456360.png)