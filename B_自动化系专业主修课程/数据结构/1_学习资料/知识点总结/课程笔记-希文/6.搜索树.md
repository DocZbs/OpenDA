高效率的动态修改和高效率的静态查找，能否同时兼顾？

## 查找

所谓的查找或搜索（ search） ，指从一组数据对象中找出符合特定条件者， 这是构建算法的一种基本而重要的操作。其中的数据对象， 统一地表示和实现为词条（ entry） 的形式； 不同词条之间， 依照各自的关键码（ key）彼此区分。  

与此前的“循秩访问” 和“循位置访问” 等完全不同， 这一新的访问方式， 与数据对象的物理位置或逻辑次序均无关。实际上，查找的过程与结果，仅仅取决于目标对象的关键码，故这种方式亦称作循关键码访问（ call-by-key） 。

  一般地，查找集内的元素，均可视作词条模板类Entry的实例化对象

```C++
template <typename K, typename V> struct Entry{//词条模板类
	K key; V value; //关键码、数值
	Entry( K k = K(), V v = V()): key(k), value(v){}; //默认构造函数
	Entry( Entry<K, V> const & e):key(e.key),value(e.value){};//克隆
	//比较器、判等器（从此，不必严格区分词条及其对应的关键码） 
	bool operator< ( Entry<K,V> const & e ){ return key < e.key;} //小于
	bool operator> ( Entry<K,V> const & e ){ return key > e.key;} //大于
	bool operator==( Entry<K,V> const & e ){ return key == e.key;} //等于
	bool operator!=( Entry<K,V> const & e ){ return key!= e.key;}//不等
}

```

设置词条类只为保证查找算法接口的统一，故不必过度封装。

通过重载对应的操作符， 可将词条的判等与比较等操作转化为关键码的判等与比较（故在不致歧义时，往往无需严格区分词条及其关键码） 。 当然，这里隐含地做了一个假定——所有词条构成一个全序关系，可以相互比对和比较。需指出的是，这一假定条件不见得总是满足。比如在人事数据库中，作为姓名的关键码之间并不具有天然的大小次序。 另外，在任务相对单纯但更加讲求效率的某些场合，并不允许花费过多时间来维护全序关系，只能转而付出有限的代价维护一个偏序关系。

##   二叉搜索树

若二叉树中各节点所对应的词条之间支持大小比较，则在不致歧义的情况下，我们可以不必严格区分树中的节点、节点对应的词条以及词条内部所存的关键码。  

在所谓的二叉搜索树（binary search tree）中，处处都满足顺序性**：任意节点r的左（右）子树中，所有节点（若存在）均不大于（不小于）r**。

![image-20211120024214741](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211120024214741.png)

顺序性是一项很强的条件。搜索树中节点的全序关系，已完全“蕴含”于这一条件之中。在二叉搜索树中，只需对该树做一次中序遍历，即可将该树转换为一个线性序列，且该序列中的节点严格按照其大小次序排列。

**任何一棵二叉树是二叉搜索树，当且仅当其中序遍历序列单调非降**  

BST模板类：

```C++
template <typename T> class BST:  public BinTree<T>{//由BinTree派生
public: //以virtual修饰，以便派生类(BST变种）重写
	virtual BinNodePosi(T) & search( const T & ); //查找
	virtual BinNodePosi(T) insert( const T & ); //插入
	virtual bool remove( const T & );//删除
protected:
	BinNodePosi(T) _hot; //命中节点的父亲
	BinNodePosi(T) connect34( //3+4重构
		BinNodePosi(T), BinNodePosi(T), BinNodePosi(T),
		BinNodePosi(T), BinNodePosi(T), BinNodePosi(T),BinNodePosi(T);
	BinNodePosi(T) rotateAt( BinNodePosi(T) );//旋转调整
	)
}
```

### 查找

二叉搜索树的查找算法，亦采用了减而治之的思路与策略，其执行过程可描述为：**从树根出发，逐步地缩小查找范围，直到发现目标（成功）或缩小至空树（失败 ）**。对照中序遍历序列可见，整个过程可视作是在仿效有序向量的**二分查找**。

```C++
template <typename T> BinNodePosi(T) & BST<T>::search(const T & e)
{return searchIn( _root, e, _hot = NULL); } //从根节点启动查找

template <typename T> //在以v为根的(AVL、SPLAY、rbTree等)BST子树中查找关键码e
static BinNodePosi(T) & searchIn(
	BinNodePosi(T) & v, //当前子根
	const T & e, //目标关键码
	BinNodePosi(T) & hot) //记忆热点
{
	if (!v || (e == v-> data)) return v; //递归基：足以确定失败、成功
	hot = v; //记下当前非空节点
	return searchIn(((e < v->data) ? v->lChild : v->rChild),e,hot); //深入一层，递归查找
    //返回时，返回值指向命中节点（或假想的通配哨兵），hot指向其父亲（退化时为初始值NULL）
}//运行时间正比于返回节点v的深度，不超过树高O(h)
```

![image-20211120025717855](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211120025717855.png)

效率：在二叉搜索树的每一层，查找算法至多访问一个节点，且只需常数时间，故总体所需时间应线性正比于查找路径长度。在最坏情况下，二叉树退化为（接近于）一条单链时，此时的查找则等效于顺序查找。故：若要控制单次查找在最坏情况下的运行时间，须从控制二叉搜索树的高度入手。

### 插入

![image-20211120030556405](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211120030556405.png)

```C++
template <typename T> BinNodePosi(T) BST<T>::insert( const T & e ){
	BinNodePosi(T) & x = search(e); //查找目标（留意_hot的位置）
	if ( !x ){ //禁止雷同元素，仅在查找失败时才实施插入操作
		x = new BinNode<T>(e,_hot); //在x处创建新节点，以_hot为父亲
		_size++; updateHeightAbove(x); //更新全树规模，更新x及其历代祖先的高度
	}
	return x; //无论e是否存在于原树中，总有x->data == e 
} //O(h) 对于首个节点插入之类的边界情况，均可正确处置

```

由上可见， 节点插入操作所需的时间， 主要消耗于对算法search()及updateHeightAbove()的调用。 后者与前者一样，在每一层次至多涉及一个节点，仅消耗O(1)时间，故其时间复杂度也同样取决于新节点的深度，在最坏情况下不超过全树的高度。  

### 删除

为从二叉搜索树中删除节点，首先需调用算法`BST::search()`，判断目标节点是否的确存在于树中，若存在，需返回其位置，然后方能相应地具体实施删除操作。

![image-20211120192419841](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211120192419841.png)

```C++
template <typename T> bool BST<T>::remove( const T & e){
	BinNodePosi(T) & x = search(e); //定位目标节点
	if ( !x ) return false; //确认目标存在（此时_hot为x的父亲）
	removeAt( x, _hot); //分两大类情况实施删除，更新全树规模
	_size--; //更新全树规模
	updateHeightAbove( _hot ); //更新_hot及其历代祖先的高度
	return true;
}//删除成功与否，由返回值指示
```

实质的删除操作由`removeAt()`函数负责分情况实施。

```C++
/*************
BST节点删除算法：删除位置x所指的节点，且其为全局静态函数
目标x在此前经查找定位，并确认非NULL，故必删除成功；与searchIn不同，调用之前不必将hot置空
返回值指向实际被删除节点的接替者，hot指向实际被删除节点的父亲，两者均有可能是NULL。

*************/
template <typename T> static BinNodePosi(T) removeAt( BinNodePosi(T) & x, BinNodePosi(T) & hot){
	BinNodePosi(T) w = x; //实际被摘除的节点
	BinNodePosi(T) succ = NULL; //被删除节点的接替者
	if (!HasLChild( *x )) succ = x = x->rChild; //左子树为空，则直接将*x替换为其右子树
	else if (!HasRChild( *x )) succ = x = x->lChild; //右子树为空
	else{//左右子树并存，需要选择x的直接后继作为实际被摘除节点
        w = w->succ(); 
        swap( x->data, w->data); //令*x与其后继*w互换数据
		BinNodePosi(T) u = w->parent; //原问题转化为摘除非二度节点w
		( u==x ? u->rChild : u->lChild )= succ = w->rChild; 
    }
    
    
	hot = w->parent; //被删除节点的父亲
	if (succ) succ->parent = hot; //将被删除节点的接替者与hot相联
	release(w->data); release(w); //释放被删除的节点
	return succ; //返回被接替者
} // O(1)

```

删除操作所需的时间，主要消耗于对search（）、succ（）和updateHeightAbove（）的调用。总体的渐进时间复杂度，不超过全树的高度。

## 平衡二叉搜索树

根据以上分析可以看出，二叉搜索树主要接口的运行时间均线性正比于二叉搜索树的高度，而在最坏情况下，二叉搜索树可能彻底退化为列表。若不能有效地控制树高，则就实际的性能而言，较之此前的向量和列表，二叉搜索树将无法体现出明显优势。

![image-20211120200334750](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211120200334750.png)

既然二叉搜索树的性能主要取决于高度，故在节点数目固定的前提下，应尽可能地降低高度，即使兄弟子树地高度彼此接近，即全树尽可能地平衡。若树高恰好为$\left\lfloor\log _{2} n\right\rfloor$，则称为理想平衡树，完全二叉树、满二叉树均属于此列。

但是完全二叉树“叶节点只能出现在最底部两层”的限制过于苛刻，相对于二叉树所有可能的形态，此类二叉树所占比例极低，可见，从算法可行性的角度来看，有必要依照某种相对宽松的标准，重新定义二叉搜索树的平衡性。

在渐进意义下适当放松标准之后的平衡性，称作适度平衡。若将树高限制为“渐进地不超过$O(\log n)$”，则下节将要介绍的AVL树，以及下一章将要介绍的伸展树、红黑树、kd树等，都属于适度平衡，这些变种，因此也都可以归入平衡二叉搜索树（balanced binary search tree， BBST）之列。

### 等价变换

![image-20211120201906964](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211120201906964.png)

![image-20211120201921715](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211120201921715.png)

![image-20211120202026371](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211120202026371.png)

## AVL树

通过合理设定适度平衡的标准，并借助以上等价变换，AVL树可以实现近乎理想的平衡。在渐进意义下，AVL树可始终将其高度控制在$O(\log n)$以内，从而保证每次查找、插入和删除操作，均可在$O(\log n)$的时间内完成。

任一节点v的平衡因子（balance factor）定义为“其左、右子树的高度差”，即balFac(v) = height (lc(v)) - height(rc(v))。空树高度取-1，叶节点高度取0与以上定义没有冲突。

所谓AVL树，即平衡因子受限的二叉搜索树——其中各节点平衡因子的绝对值均不超过1.

接口：

```C++
#define Balanced(x) \ //理想平衡
	(stature((x).lChild)==stature((x).rChild))
#define BalFac(x) \ //平衡因子
	(stature((x).lChild)-stature((x).rChild))
#define AvlBalanced(x) \ //AVL平衡条件
	((-2 < BalFac(x))&&(BalFac(x)<2))
template <typename T> class AVL: public BST<T>{
public: //BST::search()等接口可直接沿用
	BinNodePosi(T) insert( const T & ); //插入重写
	bool remove( const T & );//删除重写
}
```

由于完全二叉树中各节点的平衡因子非0即1，故完全二叉树必是AVL树。

考察AVL树的平衡性，可以证明，高度为h的AVL树至少包含fib（h+3）-1个节点，根据数学归纳法可以证明这一点。

![image-20211120205036334](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211120205036334.png)

失衡与重平衡：

![image-20211120205221881](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211120205221881.png)

### 节点插入

不难看出, 新引入节点 $x$ 后, $U T(x)$ 中的节点都是 $x$ 的祖先, 且高度不低于 $x$ 的祖父。以下, 将其中的最深者记作 $g(x)$ 。在 $x$ 与 $g(x)$ 之间的通路上, 设 $p$ 为 $g(x)$ 的孩子, $v$ 为 $p$ 的孩子。注意, 既然 $g(x)$ 不低于 $x$ 的祖父, 则 $p$ 必是 $x$ 的真祖先。

> 这个$U T(x)$说的就是失衡节点集。

首先，需要找到如上定义的$g(x)$。为此，可从x出发沿parent指针逐层上行并核对平衡因子，首次遇到的失衡祖先即为$g(x)$。既然原树是平衡的，故这一过程只需要$O(\log n)$时间。

既然$g(x)$是因为x的引入而失衡，则p和v的高度均不会低于各自的兄弟。因此，借助tallerChild（）宏，即可以反过来由$g(x)$找到p和v。

![image-20211125145653633](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211125145653633.png)

![image-20211125145731822](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211125145731822.png)

不论单旋或者双旋，经局部调整之后，不仅$g(x)$能够重获平衡，而且局部子树的高度也必将复原。这就意味着，$g(x)$以上所有祖先的平衡因子亦将统一地复原。——换而言之，在AVL树中插入新节点后，仅需不超过两次旋转，即可使整树恢复平衡。

```C++
template <typename T> BinNodePosi(T) AVL<T>::insert( const T & e){//将关键码e插入AVL树中
	BinNodePosi(T) & x = search(e);if(x) return x; //若目标尚不存在
	x = new BinNode<T>(e,_hot); size_++; BinNodePosi(T) xx = x; //则创建x
	//从x的父亲出发逐层向上，依次检查各代祖先g
	for ( BinNodePosi(T) g = x->parent; g; g = g->parent)
		if (!AvlBalanced(*g)){//一旦发现g失衡
			FromParentTo(*g)=rotateAt(tallerChild(tallerChild(g)));
			break;//g复衡后局部子树高度必复原，其祖先也如此
		}else//否则（在依然平衡的祖先处）
			updateHeight(g);//更新其高度（平衡性虽不变，高度却有可能改变）
	return xx;//返回新节点：至多只需一次调整
}//无论e是否存在于原树中，总有AVL::insert(e)->data = e
```

效率：该算法首先按照二叉搜索树的常规算法，在O(logn)时间内插入新节点x，既然原树是平衡的，故至多检查$O(\log n)$个节点即可确定$g(x)$；如有必要，至多旋转两次，即可使局部乃至全树恢复平衡，由此可见，AVL树的节点插入操作可以在$O(\log n)$时间内完成。

### 节点删除

与插入操作十分不同的是，在摘除节点x以及随后的调整过程中，失衡节点集UT(x)始终至多只含一个节点，且若该节点g(x)存在，其高度必与失衡前相同。另外还有一点重要的差异是，g(x)有可能就是x的父亲。

![image-20211125154556001](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211125154556001.png)

![image-20211125154607710](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211125154607710.png)

![image-20211125154736731](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211125154736731.png)

![image-20211125155018988](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211125155018988.png)

```C++
template <typename T> bool AVL<T>::remove( const T & e ){//从AVL树删除关键码e
	BinNodePosi(T) & x = search(e); if(!x) return false; //若目标的确存在
	removeAt(x,_hot);size--; //在按BST规则删除后，_hot及祖先均有可能失衡
	//从_hot出发逐层向上，依次检查各代祖先g
	for (BinNodePosi(T) g =_hot;g;g=g->parent){
		if(!AvlBalanced(*g)) //一旦发现g失衡，通过调整恢复平衡
			g = FromParentTo(*g)=rotateAt(tallerChild(tallerChild(g)));updateHeight(g); //更新其高度
	}//可能做Ω(logn)次调整；无论是否做调整，全树高度均可能下降
	return true; //删除成功
}
```

效率：较之插入操作，删除操作可能需在重平衡方面多花费一些时间，不过，既然需做重平衡方面多花费一些时间，不过，既然需做重平衡的节点都是x的祖先，故重平衡过程累计只需不过$O(\log n)$时间，综合各方面的消耗，AVL树的结节点删除操作总体的时间复杂度依然是$O(\log n)$。

### 统一重平衡算法

上述重平衡的方法，需要根据失衡节点及其孩子节点、孙子节点的相对位置关系，分别做单旋获双旋调整。如果按照这一思路直接实现调整算法，代码量大且流程繁杂，必然导致调试困难且容易出错。为此，引入一种更为简明的统一处理方法。

![image-20211125160826934](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211125160826934.png)

> 这个节点的命名是按照中序遍历次序排列的。

该重构算法可能的一种实现方式如下：

```C++
//按照3+4结构连接三个节点及其四棵子树，返回重组之后的局部子树根节点位置（即b）
template <typename T> BinNodePosi(T) BST<T>::connect34(BinNodePosi(T) a, BinNodePosi(T) b, BinNodePosi(T) c, BinNodePosi(T) T0, BinNodePosi(T) T1, BinNodePosi(T) T2, BinNodePosi(T) T3){
	a->lChild = T0, if (T0) T0->parent = a;
	a->rChild = T1, if (T1) T1->parent = a; updateHeight(a);
	c->lChild = T2, if (T2) T2->parent = c;
	c->rChild = T3, if (T3) T3->parent = c; updateHeight(c);
	b->lChild = a; a->parent = b;
	b->rChild = c; c->parent = b; updateHeight(b);
	return b;//该子树新的根节点
}
```

利用以上的connect34()算法，即可视不同情况，按如下具体方法完成重平衡：

```C++
/**************
BST节点旋转变换统一算法（3节点+4子树），返回调整之后局部子树根节点的位置。注意：尽管子树根会正确指向上层节点（如果存在），但反向的联接须由上层函数完成
****************/
template <typename T> BinNodePosi(T) BST<T>::rotateAt(BinNodePosi(T) v){//v为分空孙辈节点
	BinNodePosi(T) p = v->parent, g=p->parent;//父亲、祖父
	if( IsLChild(*p)) //zig
		if( IsLChild(*v)){//zig-zig
			p->parent = g->parent;//向上联接
			return connect34(v,p,g,v->lChild,v->rChild,p->rChild,g->rChild);
		}else{//zig-zag
			v->parent = g->parent;//向上联接
			return connect34(p,v,g,p->lChild,v->lChild,v->rChild,g->rChild);
		}
	else{/*...zag-zig & zag-zag...*/}
}
```

新算法的复杂度也依然是O(1)

## 伸展树

伸展树(Splay tree)也是平衡二叉搜索树的一种形式，相对于AVL树，后者的实现更为简洁。伸展树无需时刻都严格地保持全树的平衡，却能够在任何足够长的真实操作序列中，保持分摊意义上的高效率。伸展树也不需要对基本的二叉树节点结构，做任何附加的要求获改动，更不需要记录平衡因子或高度之类的额外信息，故适用范围更广。

![image-20211225133146052](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225133146052.png)

![image-20211225133618600](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225133618600.png)

![image-20211225133721999](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225133721999.png)

为了克服上述伸展调整策略的缺陷，一种简便且有效的方法就是：将逐层伸展改为双层伸展，具体地，每次都从当前节点v向上追溯两层（而不是仅一层），并根据其父亲p以及祖父g的相对位置，进行相应的旋转。

![image-20211225134436550](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225134436550.png)

自然地，另一完全对称的情形：v是p的右孩子，且p也是g的右孩子，则可通过连续的两次逆时针旋转实现调整，合称zag-zag操作。

![image-20211225134557419](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225134557419.png)

![image-20211225134612896](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225134612896.png)

![image-20211225134849770](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225134849770.png)

![image-20211225135053949](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225135053949.png)

伸展树的实现：

```C++
#include "BST/BST.h" //基于BST实现Splay
 template <typename T> class Splay : public BST<T> { //由BST派生的Splay树模板类
 protected:
    BinNodePosi<T> splay ( BinNodePosi<T> v ); //将节点v伸展至根
 public:
    BinNodePosi<T> & search ( const T& e ); //查找（重写）
    BinNodePosi<T> insert ( const T& e ); //插入（重写）
    bool remove ( const T& e ); //删除（重写）
 };
```

这里直接沿用二叉搜索树类，并根据伸展树的平衡规则，重写了三个基本操作接口`search()`、`insert()`和`remove()`，另外，针对伸展调整操作，设有一个内部保护型接口splay()。

### 伸展

```C++
template <typename NodePosi> inline //在节点*p与*lc（可能为空）之间建立父（左）子关系
 void attachAsLC ( NodePosi lc, NodePosi p ) { p->lc = lc; if ( lc ) lc->parent = p; }
 
 template <typename NodePosi> inline //在节点*p与*rc（可能为空）之间建立父（右）子关系
 void attachAsRC ( NodePosi p, NodePosi rc ) { p->rc = rc; if ( rc ) rc->parent = p; }
 
 template <typename T> //Splay树伸展算法：从节点v出发逐层伸展
 BinNodePosi<T> Splay<T>::splay ( BinNodePosi<T> v ) { //v为因最近访问而需伸展的节点位置
    if ( !v ) return NULL; 
    BinNodePosi<T> p; BinNodePosi<T> g; //*v的父亲与祖父
    while ( ( p = v->parent ) && ( g = p->parent ) ) { //自下而上，反复对*v做双层伸展
       BinNodePosi<T> gg = g->parent; //每轮之后*v都以原曾祖父（great-grand parent）为父
       if ( IsLChild ( *v ) )
          if ( IsLChild ( *p ) ) { //zig-zig
             attachAsLC ( p->rc, g ); attachAsLC ( v->rc, p );
             attachAsRC ( p, g ); attachAsRC ( v, p );
          } else { //zig-zag
             attachAsLC ( v->rc, p ); attachAsRC ( g, v->lc );
             attachAsLC ( g, v ); attachAsRC ( v, p );
          }
       else if ( IsRChild ( *p ) ) { //zag-zag
          attachAsRC ( g, p->lc ); attachAsRC ( p, v->lc );
          attachAsLC ( g, p ); attachAsLC ( p, v );
       } else { //zag-zig
          attachAsRC ( p, v->lc ); attachAsLC ( v->rc, g );
          attachAsRC ( v, g ); attachAsLC ( p, v );
       }
       if ( !gg ) v->parent = NULL; //若*v原先的曾祖父*gg不存在，则*v现在应为树根
       else //否则，*gg此后应该以*v作为左或右孩子
          ( g == gg->lc ) ? attachAsLC ( v, gg ) : attachAsRC ( gg, v );
       updateHeight ( g ); updateHeight ( p ); updateHeight ( v );
    } //双层伸展结束时，必有g == NULL，但p可能非空
    if ( p = v->parent ) { //若p果真非空，则额外再做一次单旋
       if ( IsLChild ( *v ) ) { attachAsLC ( v->rc, p ); attachAsRC ( v, p ); }
       else                   { attachAsRC ( p, v->lc ); attachAsLC ( p, v ); }
       updateHeight ( p ); updateHeight ( v );
    }
    v->parent = NULL; return v;
 } //调整之后新树根应为被伸展的节点，故返回该节点的位置以便上层函数更新树根
```

### 查找

```C++
template <typename T> BinNodePosi<T> & Splay<T>::search ( const T & e ) { //在伸展树中查找e
    BinNodePosi<T> p = BST<T>::search ( e );
    _root = splay ( p ? p : _hot ); //将最后一个被访问的节点伸展至根
    return _root;
 } //与其它BST不同，无论查找成功与否，_root都指向最后被访问的节点
```

### 插入

![image-20211225141033419](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225141033419.png)

```C++
template <typename T> BinNodePosi<T> Splay<T>::insert ( const T& e ) { //将关键码e插入伸展树中
    if ( !_root ) { _size++; return _root = new BinNode<T> ( e ); } //处理原树为空的退化情况
    if ( e == search ( e )->data ) return _root; //确认目标节点不存在
    _size++; BinNodePosi<T> t = _root; //创建新节点。以下调整<=7个指针以完成局部重构
    if ( _root->data < e ) { //插入新根，以t和t->rc为左、右孩子
       t->parent = _root = new BinNode<T> ( e, NULL, t, t->rc ); //2 + 3个
       if ( HasRChild ( *t ) ) { t->rc->parent = _root; t->rc = NULL; } //<= 2个
    } else { //插入新根，以t->lc和t为左、右孩子
       t->parent = _root = new BinNode<T> ( e, NULL, t->lc, t ); //2 + 3个
       if ( HasLChild ( *t ) ) { t->lc->parent = _root; t->lc = NULL; } //<= 2个
    }
    updateHeightAbove ( t ); //更新t及其祖先（实际上只有_root一个）的高度
    return _root; //新节点必然置于树根，返回之
 } //无论e是否存在于原树中，返回时总有_root->data == e
```

### 删除

![image-20211225142506537](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225142506537.png)

```C++
template <typename T> bool Splay<T>::remove ( const T& e ) { //从伸展树中删除关键码e
    if ( !_root || ( e != search ( e )->data ) ) return false; //若树空或目标不存在，则无法删除
    BinNodePosi<T> w = _root; //assert: 经search()后节点e已被伸展至树根
    if ( !HasLChild ( *_root ) ) { //若无左子树，则直接删除
       _root = _root->rc; if ( _root ) _root->parent = NULL;
    } else if ( !HasRChild ( *_root ) ) { //若无右子树，也直接删除
       _root = _root->lc; if ( _root ) _root->parent = NULL;
    } else { //若左右子树同时存在，则
       BinNodePosi<T> lTree = _root->lc;
       lTree->parent = NULL; _root->lc = NULL; //暂时将左子树切除
       _root = _root->rc; _root->parent = NULL; //只保留右子树
       search ( w->data ); //以原树根为目标，做一次（必定失败的）查找
 ///// assert: 至此，右子树中最小节点必伸展至根，且（因无雷同节点）其左子树必空，于是
       _root->lc = lTree; lTree->parent = _root; //只需将原左子树接回原位即可
    }
    release ( w->data ); release ( w ); _size--; //释放节点，更新规模
    if ( _root ) updateHeight ( _root ); //此后，若树非空，则树根的高度需要更新
    return true; //返回成功标志
 } //若目标节点存在且被删除，返回true；否则返回false
```

## B-树

计算机存储能力提高速度相对滞后，是长期存在的现象，而且随着时间的推移，这一矛盾将日益凸显。鉴于在同等成本下，存储器的容量越大则访问速度越慢，因此一味地提高存储器容量，亦非解决这一矛盾的良策。

实践证明，分级存储才是行之有效的方法。在由内存与外存（磁盘）组成的二级存储系统中，数据全集往往存放于外存中，计算过程中则可将内存作为外存的高速缓存，存放最常用数据项的复本。借助高效的调度算法，如此便可将内存的“高速度”与外存的“大容量”结合起来。

两个相邻存储级别之间的数据传输，统称IO操作。各级存储器的访问速度相差悬殊，故应尽可能地减少IO操作。仍以内存与磁盘为例，其单次访问延迟大致分别在纳秒和毫秒级别，因此，为减少对外存的一次访问，我们宁愿访问内存万次。也因如此，在衡量相关算法的性能时，基本可以忽略对内存的访问，转而更多地关注对外存的访问次数。

![image-20211225152104910](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225152104910.png)

![image-20211225155243974](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225155243974.png)

![image-20211225162254475](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225162254475.png)

### ADT接口及其实现

按照以上定义，可以模板类的形式描述并实现B-树节点以及B-树结构本身如下：

```C++
 #include "vector/vector.h"
 template <typename T> struct BTNode;
 template <typename T> using BTNodePosi = BTNode<T>*; //B-树节点位置
 
 template <typename T> struct BTNode { //B-树节点模板类

    BTNodePosi<T> parent; //父节点
    Vector<T> key; //关键码向量
    Vector<BTNodePosi<T>> child; //孩子向量（其长度总比key多一）
 // 构造函数（注意：BTNode只能作为根节点创建，而且初始时有0个关键码和1个空孩子指针）
    BTNode() { parent = NULL; child.insert ( 0, NULL ); }
    BTNode ( T e, BTNodePosi<T> lc = NULL, BTNodePosi<T> rc = NULL ) {
       parent = NULL; //作为根节点，而且初始时
       key.insert ( 0, e ); //只有一个关键码，以及
       child.insert ( 0, lc ); child.insert ( 1, rc ); //两个孩子
       if ( lc ) lc->parent = this; if ( rc ) rc->parent = this;
    }
 };
```

这里，同一节点的所有孩子组织为一个向量，各相邻孩子之间的关键码也组织为一个向量。当然，按照B-树的定义，孩子向量的实际长度总是比关键码向量多一。

相应地，B树模板类可以实现如下。

```C++
#include "BTNode.h" //引入B-树节点类
 
 template <typename T> class BTree { //B-树模板类
 protected:
    int _size; //存放的关键码总数
    int _order; //B-树的阶次，至少为3——创建时指定，一般不能修改
    BTNodePosi<T> _root; //根节点
    BTNodePosi<T> _hot; //BTree::search()最后访问的非空（除非树空）的节点位置
    void solveOverflow ( BTNodePosi<T> ); //因插入而上溢之后的分裂处理
    void solveUnderflow ( BTNodePosi<T> ); //因删除而下溢之后的合并处理
 public:
    BTree ( int order = 3 ) : _order ( order ), _size ( 0 ) //构造函数：默认为最低的3阶
    { _root = new BTNode<T>(); }
    ~BTree() { if ( _root ) release ( _root ); } //析构函数：释放所有节点
    int const order() { return _order; } //阶次
    int const size() { return _size; } //规模
    BTNodePosi<T> & root() { return _root; } //树根
    bool empty() const { return !_root; } //判空
    BTNodePosi<T> search ( const T& e ); //查找
    bool insert ( const T& e ); //插入
    bool remove ( const T& e ); //删除
 }; //BTree
```

### 关键码查找

![image-20211225183445018](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225183445018.png)

![image-20211225183542389](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225183542389.png)

```C++
template <typename T> BTNodePosi<T> BTree<T>::search ( const T& e ) { //在B-树中查找关键码e
    BTNodePosi<T> v = _root; _hot = NULL; //从根节点出发
    while ( v ) { //逐层查找
       Rank r = v->key.search ( e ); //在当前节点中，找到不大于e的最大关键码
       if ( ( 0 <= r ) && ( e == v->key[r] ) ) return v; //成功：在当前节点中命中目标关键码
       _hot = v; v = v->child[r + 1]; //否则，转入对应子树（_hot指向其父）——需做I/O，最费时间
    } //这里在向量内是二分查找，但对通常的_order可直接顺序查找
    return NULL; //失败：最终抵达外部节点
 }
```

与二叉搜索树的实现类似，这里也约定查找结果由返回的节点位置取代：成功时返回目标关键码所在的节点，上层调用过程可在节点内进一步查找以确定准确的命中位置；失败时返回对应外部节点，其父节点则有变量_hot指代。

性能分析：

![image-20211225184212562](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225184212562.png)

![image-20211225184225914](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225184225914.png)

![image-20211225184251140](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225184251140.png)

### 关键码插入

```C++
template <typename T> bool BTree<T>::insert ( const T& e ) { //将关键码e插入B树中
    BTNodePosi<T> v = search ( e ); if ( v ) return false; //确认目标节点不存在
    Rank r = _hot->key.search ( e ); //在节点_hot的有序关键码向量中查找合适的插入位置
    _hot->key.insert ( r + 1, e ); //将新关键码插至对应的位置
    _hot->child.insert ( r + 2, NULL ); //创建一个空子树指针
    _size++; //更新全树规模
    solveOverflow ( _hot ); //如有必要，需做分裂
    return true; //插入成功
 }
```

![image-20211225184631586](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225184631586.png)

### 上溢与分裂

![image-20211225184858324](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225184858324.png)

![image-20211225185041102](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225185041102.png)

```C++
template <typename T> //关键码插入后若节点上溢，则做节点分裂处理
 void BTree<T>::solveOverflow ( BTNodePosi<T> v ) {
    if ( _order >= v->child.size() ) return; //递归基：当前节点并未上溢
    Rank s = _order / 2; //轴点（此时应有_order = key.size() = child.size() - 1）
    BTNodePosi<T> u = new BTNode<T>(); //注意：新节点已有一个空孩子
    for ( Rank j = 0; j < _order - s - 1; j++ ) { //v右侧_order-s-1个孩子及关键码分裂为右侧节点u
       u->child.insert ( j, v->child.remove ( s + 1 ) ); //逐个移动效率低
       u->key.insert ( j, v->key.remove ( s + 1 ) ); //此策略可改进
    }
    u->child[_order - s - 1] = v->child.remove ( s + 1 ); //移动v最靠右的孩子
    if ( u->child[0] ) //若u的孩子们非空，则
       for ( Rank j = 0; j < _order - s; j++ ) //令它们的父节点统一
          u->child[j]->parent = u; //指向u
    BTNodePosi<T> p = v->parent; //v当前的父节点p
    if ( !p ) { _root = p = new BTNode<T>(); p->child[0] = v; v->parent = p; } //若p空则创建之
    Rank r = 1 + p->key.search ( v->key[0] ); //p中指向v的指针的秩
    p->key.insert ( r, v->key.remove ( s ) ); //轴点关键码上升
    p->child.insert ( r + 1, u );  u->parent = p; //新节点u与父节点p互联
    solveOverflow ( p ); //上升一层，如有必要则继续分裂——至多递归O(logn)层
 }
```

![image-20211225185512950](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225185512950.png)

### 关键码删除

```C++
template <typename T> bool BTree<T>::remove ( const T& e ) { //从BTree树中删除关键码e
    BTNodePosi<T> v = search ( e ); if ( !v ) return false; //确认目标关键码存在
    Rank r = v->key.search ( e ); //确定目标关键码在节点v中的秩（由上，肯定合法）
    if ( v->child[0] ) { //若v非叶子，则e的后继必属于某叶节点
       BTNodePosi<T> u = v->child[r+1]; //在右子树中一直向左，即可
       while ( u->child[0] ) u = u->child[0]; //找出e的后继
       v->key[r] = u->key[0]; v = u; r = 0; //并与之交换位置
    } //至此，v必然位于最底层，且其中第r个关键码就是待删除者
    v->key.remove ( r ); v->child.remove ( r + 1 ); _size--; //删除e，以及其下两个外部节点之一
    solveUnderflow ( v ); //如有必要，需做旋转或合并
    return true;
 }
```

![image-20211225185934399](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225185934399.png)

### 下溢与合并

![image-20211225190050224](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225190050224.png)

![image-20211225190105291](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225190105291.png)

![image-20211225190417689](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211225190417689.png)

```C++
template <typename T> //关键码删除后若节点下溢，则做节点旋转或合并处理
 void BTree<T>::solveUnderflow ( BTNodePosi<T> v ) {
    if ( ( _order + 1 ) / 2 <= v->child.size() ) return; //递归基：当前节点并未下溢
    BTNodePosi<T> p = v->parent;
    if ( !p ) { //递归基：已到根节点，没有孩子的下限
       if ( !v->key.size() && v->child[0] ) {
          //但倘若作为树根的v已不含关键码，却有（唯一的）非空孩子，则
          _root = v->child[0]; _root->parent = NULL; //这个节点可被跳过
          v->child[0] = NULL; release ( v ); //并因不再有用而被销毁
       } //整树高度降低一层
       return;
    }
    Rank r = 0; while ( p->child[r] != v ) r++;
    //确定v是p的第r个孩子——此时v可能不含关键码，故不能通过关键码查找
    //另外，在实现了孩子指针的判等器之后，也可直接调用Vector::find()定位
 // 情况1：向左兄弟借关键码
    if ( 0 < r ) { //若v不是p的第一个孩子，则
       BTNodePosi<T> ls = p->child[r - 1]; //左兄弟必存在
       if ( ( _order + 1 ) / 2 < ls->child.size() ) { //若该兄弟足够“胖”，则
          v->key.insert ( 0, p->key[r - 1] ); //p借出一个关键码给v（作为最小关键码）
          p->key[r - 1] = ls->key.remove ( ls->key.size() - 1 ); //ls的最大关键码转入p
          v->child.insert ( 0, ls->child.remove ( ls->child.size() - 1 ) );
          //同时ls的最右侧孩子过继给v
          if ( v->child[0] ) v->child[0]->parent = v; //作为v的最左侧孩子
          return; //至此，通过右旋已完成当前层（以及所有层）的下溢处理
       }
    } //至此，左兄弟要么为空，要么太“瘦”
 // 情况2：向右兄弟借关键码
    if ( p->child.size() - 1 > r ) { //若v不是p的最后一个孩子，则
       BTNodePosi<T> rs = p->child[r + 1]; //右兄弟必存在
       if ( ( _order + 1 ) / 2 < rs->child.size() ) { //若该兄弟足够“胖”，则
          v->key.insert ( v->key.size(), p->key[r] ); //p借出一个关键码给v（作为最大关键码）
          p->key[r] = rs->key.remove ( 0 ); //rs的最小关键码转入p
          v->child.insert ( v->child.size(), rs->child.remove ( 0 ) );
          //同时rs的最左侧孩子过继给v
          if ( v->child[v->child.size() - 1] ) //作为v的最右侧孩子
             v->child[v->child.size() - 1]->parent = v;
          return; //至此，通过左旋已完成当前层（以及所有层）的下溢处理
       }
    } //至此，右兄弟要么为空，要么太“瘦”
 // 情况3：左、右兄弟要么为空（但不可能同时），要么都太“瘦”——合并
    if ( 0 < r ) { //与左兄弟合并
       BTNodePosi<T> ls = p->child[r - 1]; //左兄弟必存在
       ls->key.insert ( ls->key.size(), p->key.remove ( r - 1 ) ); p->child.remove ( r );
       //p的第r - 1个关键码转入ls，v不再是p的第r个孩子
       ls->child.insert ( ls->child.size(), v->child.remove ( 0 ) );
       if ( ls->child[ls->child.size() - 1] ) //v的最左侧孩子过继给ls做最右侧孩子
          ls->child[ls->child.size() - 1]->parent = ls;
       while ( !v->key.empty() ) { //v剩余的关键码和孩子，依次转入ls
          ls->key.insert ( ls->key.size(), v->key.remove ( 0 ) );
          ls->child.insert ( ls->child.size(), v->child.remove ( 0 ) );
          if ( ls->child[ls->child.size() - 1] ) ls->child[ls->child.size() - 1]->parent = ls;
       }
       release ( v ); //释放v
    } else { //与右兄弟合并
       BTNodePosi<T> rs = p->child[r + 1]; //右兄弟必存在
       rs->key.insert ( 0, p->key.remove ( r ) ); p->child.remove ( r );
       //p的第r个关键码转入rs，v不再是p的第r个孩子
       rs->child.insert ( 0, v->child.remove ( v->child.size() - 1 ) );
       if ( rs->child[0] ) rs->child[0]->parent = rs; //v的最右侧孩子过继给rs做最左侧孩子
       while ( !v->key.empty() ) { //v剩余的关键码和孩子，依次转入rs
          rs->key.insert ( 0, v->key.remove ( v->key.size() - 1 ) );
          rs->child.insert ( 0, v->child.remove ( v->child.size() - 1 ) );
          if ( rs->child[0] ) rs->child[0]->parent = rs;
       }
       release ( v ); //释放v
    }
    solveUnderflow ( p ); //上升一层，如有必要则继续分裂——至多递归O(logn)层
    return;
 }
```

如前所述，若下溢现象持续传播至树根，且树根当时仅含一个关键码，于是，在其仅有的两个孩子被合并，仅有的一个关键码被借出后，原树根将退化为单分支节点。对这一特殊情况，需删除该树根，并以刚合并而成的节点作为新的树根，整树高度也随之降低一层。

## 红黑树

平衡二叉搜索树的形式多样，且各具特色，比如，伸展树实现简便、无需修改节点结构、分摊复杂度低，但可惜最坏情况下的单次操作需要$\Omega(\mathrm{n})$时间，故难以适用于核电站、医院等对可靠性和稳定性要求极高的场合。AVL树尽管可以保证最坏情况下的单次操作速度，但需在节点中嵌入平衡因子等标识；更重要的是，删除操作之后的重平衡可能需做多达$\Omega(\log n)$次旋转，从而频繁地导致全树整体拓扑结构的大幅变化。

红黑树即是针对后一不足的改进，通过为节点指定颜色，并巧妙地动态调整，红黑树可以保证，在每次插入或删除操作之后的重平衡过程中，全树拓扑结构的更新仅涉及常数个节点。尽管最坏情况下需对多达$\Omega(\log n)$个节点重染色，但就分摊意义而言仅为O(1)个。

当然，为此首先需在AVL树“适度平衡”标准的基础上，进一步放宽条件。实际上，红黑树所采用的“适度平衡”标准，可大致表述为：任一节点左、右子树的高度，相差不得超过两倍。

![image-20211231021402829](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211231021402829.png)

![image-20211231021429981](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211231021429981.png)

![image-20211231021449856](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211231021449856.png)

### 红黑树模板类

可以从BST模板类派生出RedBlack模板类：

```C++
#include "BST/BST.h" //基于BST实现RedBlack
 template <typename T> class RedBlack : public BST<T> { //RedBlack树模板类
 protected:
    void solveDoubleRed ( BinNodePosi<T> x ); //双红修正
    void solveDoubleBlack ( BinNodePosi<T> x ); //双黑修正
    int updateHeight ( BinNodePosi<T> x ); //更新节点x的高度
 public:
    BinNodePosi<T> insert ( const T& e ); //插入（重写）
    bool remove ( const T& e ); //删除（重写）
 // BST::search()等其余接口可直接沿用
 };
```

这里直接沿用了二叉搜索树标准的查找算法search()，并根据红黑树的重平衡规则与算法，重写了insert()和remove()接口；新加的两个内部功能接口solveDoubleRed()和solveDoubleBlack()，分别用于在节点插入或删除之后恢复全树平衡。另外，这里还需要使用此前二叉树节点模板类BinNode中预留的两个成员变量height和color。

![image-20211230201426700](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211230201426700.png)

### 节点插入算法

![image-20211230201717350](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211230201717350.png)

![image-20211226125457165](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211226125457165.png)

> 第三条也可以表述为，每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）

![image-20211226125716260](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211226125716260.png)

![image-20211226125820675](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211226125820675.png)

![image-20211230202123531](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211230202123531.png)

![image-20211230202205742](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211230202205742.png)

![image-20211230202253144](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211230202253144.png)

```C++
/******************************************************************************************
  * RedBlack双红调整算法：解决节点x与其父均为红色的问题。分为两大类情况：
  *    RR-1：2次颜色翻转，2次黑高度更新，1~2次旋转，不再递归
  *    RR-2：3次颜色翻转，3次黑高度更新，0次旋转，需要递归
0005  ******************************************************************************************/
 template <typename T> void RedBlack<T>::solveDoubleRed ( BinNodePosi<T> x ) { //x当前必为红
    if ( IsRoot ( *x ) ) //若已（递归）转至树根，则将其转黑，整树黑高度也随之递增
       {  _root->color = RB_BLACK; _root->height++; return;  } //否则，x的父亲p必存在
    BinNodePosi<T> p = x->parent; if ( IsBlack ( p ) ) return; //若p为黑，则可终止调整。否则
    BinNodePosi<T> g = p->parent; //既然p为红，则x的祖父必存在，且必为黑色
    BinNodePosi<T> u = uncle ( x ); //以下，视x叔父u的颜色分别处理
    if ( IsBlack ( u ) ) { //u为黑色（含NULL）时
       if ( IsLChild ( *x ) == IsLChild ( *p ) ) //若x与p同侧（即zIg-zIg或zAg-zAg），则
          p->color = RB_BLACK; //p由红转黑，x保持红
       else //若x与p异侧（即zIg-zAg或zAg-zIg），则
          x->color = RB_BLACK; //x由红转黑，p保持红
       g->color = RB_RED; //g必定由黑转红
 ///// 以上虽保证总共两次染色，但因增加了判断而得不偿失
 ///// 在旋转后将根置黑、孩子置红，虽需三次染色但效率更高
       BinNodePosi<T> gg = g->parent; //曾祖父（great-grand parent）
       BinNodePosi<T> r = FromParentTo ( *g ) = rotateAt ( x ); //调整后的子树根节点
       r->parent = gg; //与原曾祖父联接
    } else { //若u为红色
       p->color = RB_BLACK; p->height++; //p由红转黑
       u->color = RB_BLACK; u->height++; //u由红转黑
       if ( !IsRoot ( *g ) ) g->color = RB_RED; //g若非根，则转红
       solveDoubleRed ( g ); //继续调整g（类似于尾递归，可优化为迭代形式）
    }
 }
```

### 节点删除算法

```C++
template <typename T> bool RedBlack<T>::remove ( const T& e ) { //从红黑树中删除关键码e
    BinNodePosi<T> & x = search ( e ); if ( !x ) return false; //确认目标存在（留意_hot的设置）
    BinNodePosi<T> r = removeAt ( x, _hot ); if ( ! ( --_size ) ) return true; //实施删除
 // assert: _hot某一孩子刚被删除，且被r所指节点（可能是NULL）接替。以下检查是否失衡，并做必要调整
    if ( ! _hot ) //若刚被删除的是根节点，则将其置黑，并更新黑高度
       { _root->color = RB_BLACK; updateHeight ( _root ); return true; }
 // assert: 以下，原x（现r）必非根，_hot必非空
    if ( BlackHeightUpdated ( *_hot ) ) return true; //若所有祖先的黑深度依然平衡，则无需调整
    if ( IsRed ( r ) ) //否则，若r为红，则只需令其转黑
       { r->color = RB_BLACK; r->height++; return true; }
 // assert: 以下，原x（现r）均为黑色
    solveDoubleBlack ( r ); return true; //经双黑调整后返回
 } //若目标节点存在且被删除，返回true；否则返回false
```

![image-20211230203554245](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211230203554245.png)

![image-20211230203643523](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211230203643523.png)

![image-20211230203655585](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211230203655585.png)

![image-20211230203706808](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211230203706808.png)

![image-20211230203735540](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211230203735540.png)

![image-20211230203809839](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211230203809839.png)

```C++
/******************************************************************************************
  * RedBlack双黑调整算法：解决节点x与被其替代的节点均为黑色的问题
  * 分为三大类共四种情况：
  *    BB-1 ：2次颜色翻转，2次黑高度更新，1~2次旋转，不再递归
  *    BB-2R：2次颜色翻转，2次黑高度更新，0次旋转，不再递归
  *    BB-2B：1次颜色翻转，1次黑高度更新，0次旋转，需要递归
  *    BB-3 ：2次颜色翻转，2次黑高度更新，1次旋转，转为BB-1或BB2R
  ******************************************************************************************/
 template <typename T> void RedBlack<T>::solveDoubleBlack ( BinNodePosi<T> r ) {
    BinNodePosi<T> p = r ? r->parent : _hot; if ( !p ) return; //r的父亲
    BinNodePosi<T> s = ( r == p->lc ) ? p->rc : p->lc; //r的兄弟
    if ( IsBlack ( s ) ) { //兄弟s为黑
       BinNodePosi<T> t = NULL; //s的红孩子（若左、右孩子皆红，左者优先；皆黑时为NULL）
       if ( IsRed ( s->rc ) ) t = s->rc; //右子
       if ( IsRed ( s->lc ) ) t = s->lc; //左子
       if ( t ) { //黑s有红孩子：BB-1
          RBColor oldColor = p->color; //备份原子树根节点p颜色，并对t及其父亲、祖父
       // 以下，通过旋转重平衡，并将新子树的左、右孩子染黑
          BinNodePosi<T> b = FromParentTo ( *p ) = rotateAt ( t ); //旋转
          if ( HasLChild ( *b ) ) { b->lc->color = RB_BLACK; updateHeight ( b->lc ); } //左子
          if ( HasRChild ( *b ) ) { b->rc->color = RB_BLACK; updateHeight ( b->rc ); } //右子
          b->color = oldColor; updateHeight ( b ); //新子树根节点继承原根节点的颜色
       } else { //黑s无红孩子
          s->color = RB_RED; s->height--; //s转红
          if ( IsRed ( p ) ) { //BB-2R
             p->color = RB_BLACK; //p转黑，但黑高度不变
          } else { //BB-2B
             p->height--; //p保持黑，但黑高度下降
             solveDoubleBlack ( p ); //递归上溯
          }
       }
    } else { //兄弟s为红：BB-3
       s->color = RB_BLACK; p->color = RB_RED; //s转黑，p转红
       BinNodePosi<T> t = IsLChild ( *s ) ? s->lc : s->rc; //取t与其父s同侧
       _hot = p; FromParentTo ( *p ) = rotateAt ( t ); //对t及其父亲、祖父做平衡调整
       solveDoubleBlack ( r ); //继续修正r处双黑——此时的p已转红，故后续只能是BB-1或BB-2R
    }
 }
```



## kd-树

kd树是一种平衡二叉树，一种二叉空间分割树（BSP），一种高维几何搜索的数据结构。

> 高维数据的两类查找问题：
>
> - 与某个点最近的r个点
> - 在某个范围区间内的所有点

范围查询：

![image-20211125163408260](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211125163408260.png)

**预处理**

在典型的范围查询应用中，输入点集数据与查询区域的特点迥异。一方面，输入点集P通常会在相当长的时间内保持固定——数据的这种给出及处理方式，称作批处理（batch）或离线（offline）方式。同时，对于同一输入点集，往往需要针对大量的随机定义的区间R，反复地进行查询——数据的这种给出及处理方式，称作在线（online）方式。

因此，只要通过适当的预处理，将输入点集P提前整理和组织为某种适当的数据结构，就有可能进一步提高此后各次查询操作的效率。

![image-20211125234008177](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211125234008177.png)



在多次查询、命中占比小时有序向量搜索的效率更高。

![image-20211125234036884](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211125234036884.png)

**平衡二叉搜索树**

![image-20211125234425880](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211125234425880.png)

![image-20211125234546641](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211125234546641.png)

效率：在每一次查询的过程中，针对左、右端点的两次查找及其路径的重走，各自不过$O(\log n)$时间（实际上，这些操作还可以进一步合并精简）。在树中的每一层次上，两条路径各自至多报告一棵子树，故累计不过$O(\log n)$棵。幸运的是，为枚举出这些子树中的点，对它们的遍历累计不超过$O(r)$的时间，其中r为实际报告的点数。

综合以上分析，每次查询都可在$O(r+\log n)$时间内完成。该查询算法的运行时间也与输出规模相关，故同样属于输出敏感的算法。新算法的效率尽管并不高于基于有序向量的算法，却可以便捷地推广至二维甚至更高维。

kd-树的名字来源于“k-dimensional tree”的缩写，适用于任意指定维度的欧氏空间，并视具体的维度，相应地分别称作2d-树、3d-树、......故上节所介绍的一维平衡二叉搜索树也可称作1d-树。

![image-20211126234201985](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211126234201985.png)

![image-20211126234315682](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211126234315682.png)

2d-树构造的核心思想：每次选取一个维度进行划分

- 点深度为偶（奇）时，则沿垂直（水平）方向划分
- 每次切分都在中位点（对应坐标居中点），保证全树不高于$O(\log n)$

具体地，2d-树的整个构造过程，可形式化地递归描述如下所示：

```C++
KdTree* buildKdTree(P,d){//在深度为d的层次，构造一棵对应于（子）集合P的（子）2d-树
    if(P == {p}) return CreateLeaf(p);//递归基
    root = CreateKdNode();//创建（子）树根
    root->splitDirection = Even(d) ? VERTICAL : HORIZONTAL;//确定划分方向
    root->splitiLine = FindMedian(root->splitDirection,P);//确定中位点
    (P1,P2) = Divide(P,root->splitDirection,root->splitLine);//子集划分
    root->lc = buildkdTree(P1, d + 1);//在深度为d+1的层次，递归构造左子树
    root->rc = buildKdTree(P2,d + 1)；//在深度为d+1的层次，递归构造右子树
    return root;//返回（子）树根
}
```

![image-20211127003415181](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211127003415181.png)

> 注意：左边和底边开放，右边和顶边封闭。

**基于2d-树的范围查询**

![image-20211127004328465](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211127004328465.png)

可以将这个过程理解为一个剪枝的过程：

![image-20211127005815950](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211127005815950.png)

以上查询过程，可递归地描述如下：

![image-20211127004620096](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211127004620096.png)

![image-20211127004741159](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211127004741159.png)

2d-树的实现

```C++
struct Coordinate{
        double m_coor[2]; // 点的坐标
}
struct PointStruct : public Coordinate{
    char m_data;  
    // 点数据的类型
}
struct TreeNode : public PointStruct{
    int m_dim; 
    // 0为x方向划分，1为y方向划分
    TreeNode* m_pLeftChild; // 左孩子
    TreeNode* m_pRightChild; // 右孩子
}
struct KdTree{
    TreeNode* m_pRoot;
}
struct RecArea{
    // 存放矩形区域左下和右上坐标
    Coordinate m_minCoor;
    Coordinate m_maxCoor;
}
```

2d-树构造实现：

```C++
TreeNode* KdTree::buildTree(std::vector<PointStruct>& pList, int d)
{      // 在深度为d的层次，构造一棵对应于（子）集合pointList（pL)的(子）2d-树
    if (pList.empty()) return NULL;
    int dimension = d % 2;                                  // 确定划分方向
    PointStruct medianP = findMedialPoint(dimension, pList);
                                                              // 确定中位点
    std::vector<PointStruct> pListLeft, pListRight;       // 左右子树的点集
    for (int i = 0; i < pList.size(); i++)
        if (medianP.isBigger(dimension, pList[i]) //点的dimension轴坐标小于中位点
		pListLeft.push_back(pList[i]);              // 归入左子树
        else if (medianP.isSmaller(dimension, pList[i]))  // 轴坐标小于中位点
		pListRight.push_back(pList[i]);             // 归入右子树
        else if (! medianP.isEqual(pList[i]))         // 多个点落在中位线的情况
		pListRight.push_back(pList[i]);   // 除了中位点外其它归入右子树

    TreeNode* pTreeNode = new TreeNode(mediaP); //创建子树根,复制节点数据为mediaP
    pTreeNode->m_pLeft = buildTree(pListLeft, d + 1);   // 深度d+1构建左子树      
    pTreeNode->m_pRight = buildTree(pListRight, d + 1); // 深度d+1构建右子树 
    pTreeNode->m_dimesion = dimension;                 // 设置节点的分割轴方向
    return pTreeNode;
}
```

2d-树范围查询实现：

```C++
void KdTree::Search_R(TreeNode* pNode, int d, const RecArea& R, std::vector<PointStruct>& result) //递归搜索R范围内的点，返回于result
{
    if (!pNode) return;                // 节点为空返回
    int dimension = d % 2;             // 获得当前分割轴方向
    int flag = R.intersect(dimension, *pNode); //判断节点与R交叠情况
    if (flag < 0)                           // 只有左子树相交的情况
        Search_R(pNode->m_pLeft, d + 1, R, result);
    else if (flag > 0)                      // 只有右子树相交的情况
        Search_R(pNode->m_pRight, d + 1, R, result);
    else {                                  // 左右子树都相交的情况
        RecArea smallerR, biggerR;
        R.split(dimension, *pNode, smallerR, biggerR); // 划分区域
        Search_R(pNode->m_pLeft, d + 1, smallerR, result); 
        Search_R(pNode->m_pRight, d + 1, biggerR, result);
                           // 分别在左右子树搜索，搜索区域划分为小区域
        if (R.include(*pNode)) result.push_back(*pNode); 
    } // 判断节点是否属于R
}
```

对于k维空间的kd-树：

![image-20211127010310031](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211127010310031.png)

例子：

上面抽象的定义和算法确实是很不好理解，举一个例子会清楚很多。首先随机在 $\mathbb{R}^{2}$ 中随机生成 13 个点作为我们的数据集。起始的切分轴 $r=0$; 这里 $r=0$ 对应 $\mathrm{XX}$ 轴，而 $r=1$ 对应 $\mathrm{y}$ 轴。

![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-d1665bb6c7960176507bbf8d782f01b6_720w.png)

首先先沿 x 坐标进行切分，我们选出 x 坐标的中位点，获取最根部节点的坐标并且按照该点的x坐标将空间进行切分，所有 x 坐标小于 6.27 的数据用于构建左枝，x坐标大于 6.27 的点用于构建右枝。



![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-1c60d2523dfc2c27425958a054f933cb_720w.png)

在下一步中 $r=0+1=1 \bmod 2$ 对应 $\mathrm{y}$ 轴，左右两边再按照 $\mathrm{y}$ 轴的排序进行切分，中位点 记载于左右枝的节点。得到下面的树，左边的 $x$ 是指这该层的节点都是沿 $x$ 轴进行分割的。

空间的切分如下



![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-c02426aa371321efe97b86da66e027ab_720w.png)

![image-20211127011621459](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211127011621459.png)

最近邻查询算法：

1. 查询：目标Q从根结点开始，按Q与各个结点的比较结果向下访问Kd-Tree，直至叶结点。其中Q与结点的比较指的是将Q对应于结点中的k维度上的值与m进行比较，若Q(k) < m，则访问左子树，否则访问右子树。达到叶子结点时，计算Q与叶子结点上保存的数据之间的距离，记录下最小距离对应的数据点，记为当前“最近邻点”Pmin和最小距离Dmin。

2. 回溯（Backtracking）： 为找到离Q更近的“最近邻点”。即判断未被访问过的分支里是否还有离Q更近的点，它们之间的距离小于Dmin。如果Q与其父结点下的未被访问过的分支之间的距离小于Dmin，则认为该分支中存在离P更近的数据，进入该结点，进行（1）步骤一样的查找过程，如果找到更近的数据点，则更新为当前的“最近邻点”Pmin ，并更新Dmin 。如果Q与其父结点下的未被访问过的分支之间的距离大于Dmin ，则说明该分支内不存在与Q更近的点。回溯的判断过程是从下往上进行的，直到回溯到根结点时已经不存在与P更近的分支为止。 

   > 对于树某节点，若目标点位于树的左子数，则最近点更有可能位于左子树；但不能排除最近点在右子树的可能。所以左右子树都需要遍历。
   >
   > 但是，如果当前已知的最短距离已经小于目标点离右子树的距离，则，可对右子树进行剪枝。

2d-树最近邻查询实现：

```C++
void KdTree::recurSearch(TreeNode* pNode, int depth, const Coordinate& point, PointStruct& nearest){
    if (!pNode) return;
    int dimension = depth % 2;
    if (point.distance(*pNode) < point.distance(nearest))
        nearest = *pNode;//这是查询过程，即递归中的先序遍历，先访问根节点数据
    if (point.isSmaller(dimension, *pNode)){
        recurSearch(pNode->m_pLChild, depth + 1, point, nearest);
        if (point.distance(nearest) >= point.distance(dimension,*pNode))
             recurSearch(pNode->m_pRChild, depth + 1, point, nearest);
    }//分情况进行左右子树的查询与回溯，目标位于左子树必进入，右子树视回溯过程的垂直距离判断是否进入
    else{
        recurSearch(pNode->m_pRChild, depth + 1, point, nearest);
        if (point.distance(nearest) >= point.distance(dimension,*pNode))
	 recurSearch(pNode->m_pLChild, depth + 1, point, nearest);
    }
}
```

kNN（k近邻）算法：

![image-20211127013339452](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/image-20211127013339452.png)

设我们想查询的点为 p=(−1,−5)，设距离函数是普通的L2距离，我们想找距离问题点最近的 k=3 个点。如下：

![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-cdf36addbbeb443e2049682cf0c01e61_720w.png)

首先执行 (一)，我们按照切分找到最底部节点。首先，我们在顶部开始



![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-88b9737ae323ed9679761ff060b7c85a_720w.png)

和这个节点的 x 轴比较一下，





![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-7661de7c358c50406b9b9ce0f2e8a5a9_720w.png)

p 的 x 轴更小。因此我们向左枝进行搜索：





![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-05449d41804201bbb586bb40ef8dc27c_720w.png)

这次对比 y 轴，



![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-4ada47bf58c60dd90c539e34a4c62175_720w.png)



p 的 y 值更小，因此向左枝进行搜索：



![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-9dce4b4af30cc884be28f70cbdf92e8a_720w.png)

这个节点只有一个子枝，就不需要对比了。由此找到了最底部的节点 (−4.6,−10.55)。





![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-f3bf5299b1b137abde18f40a3634de2f_720w.png)

在二维图上是



![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-4db948a6413d4806f2fc2dfcbf1e6777_720w.png)

此时我们执行 (二)。将当前结点标记为访问过，并记录下 L=[(−4.6,−10.55)]。啊，访问过的节点就在二叉树上显示为被划掉的好了。

然后执行 (三)，嗯，不是最顶端节点。好，执行 (a)，我爬。上面的是 (−6.88,−5.4)。

![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-da6364611f5eda14d73614a23c3c553b_720w.png)

![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-918408139c3061c274876eeb4916fbfd_720w.png)

执行 (1)，因为我们记录下的点只有一个，小于 k=3，所以也将当前节点记录下，有 L=[(−4.6,−10.55),(−6.88,−5.4)].再执行 (2)，因为当前节点的左枝是空的，所以直接跳过，回到步骤 (三)。(三) 看了一眼，好，不是顶部，交给你了，(a)。于是乎 (a) 又往上爬了一节。

![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-f61a7ad09d8f2c684ef4917e716b99dd_720w.png)



![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-ae096cc31bb0e7c20c80f6fabcb26400_720w.png)

(1) 说，由于还是不够三个点，于是将当前点也记录下，有 L=[(−4.6,−10.55),(−6.88,−5.4),(1.24,−2.86)]。当然，当前结点变为被访问过的。

(2) 又发现，当前节点有其他的分枝，并且经计算得出 p 点和 L 中的三个点的距离分别是 6.62,5.89,3.10，但是 p 和当前节点的分割线的距离只有 2.14，小于与 L 的最大距离：

![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-8716b2e5ed1725fcbb41128653fa030f_720w.png)

因此，在分割线的另一端可能有更近的点。于是我们在当前结点的另一个分枝从头执行 (一)。好，我们在红线这里：

![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-f950bff44dd2d82a57683b201b5373ad_720w.png)

要用 p 和这个节点比较 x 坐标:



![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-3adf1cab1bedf796454a56759bc195b7_720w.png)

p 的 x 坐标更大，因此探索右枝 (1.75,12.26)，并且发现右枝已经是最底部节点，因此启动 (二)。





![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-002fd557426c131d7c821efff69602ef_720w.png)

经计算，(1.75,12.26) 与 p 的距离是 17.48，要大于 p 与 L 的距离，因此我们不将其放入记录中。



![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-1928b4097830a1e5496a62f843e43da9_720w.png)

然后 (三) 判断出不是顶端节点，呼出 (a)，爬。



![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-aa6a3ce45e8a8b08fdf4801bb55c7b74_720w.png)

(1) 出来一算，这个节点与 p 的距离是 4.91，要小于 p 与 L 的最大距离 6.62。



![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-85ca3283584e72a3e4320f70aa1f105c_720w.png)

因此，我们用这个新的节点替代 L 中离 p 最远的 (−4.6,−10.55)。

![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-0eb0bb9922dc1960255516643ee06f6b_720w.png)

然后 (2) 又来了，我们比对 p 和当前节点的分割线的距离

![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-4c37b348889502952051a92b940bd355_720w.png)

这个距离小于 L 与 p 的最小距离，因此我们要到当前节点的另一个枝执行 (一)。当然，那个枝只有一个点，直接到 (二)。

![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-06ae9bf7c3ee8763cb45288a5fab5922_720w.png)

计算距离发现这个点离 p 比 L 更远，因此不进行替代。

![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-0104f635fee445e0f1666c22ef6cb1d4_720w.png)

(三) 发现不是顶点，所以呼出 (a)。我们向上爬，

![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-89af7dbd49d1a2adbbab99fde618f469_720w.png)

这个是已经访问过的了，所以再来（a），

![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-e818d76f35cd380ea21f4102cec17d26_720w.png)

好，（a）再爬，

![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-8300069c7769b522dfb5a14d062045ab_720w.png)

啊！到顶点了。所以完了吗？当然不，还没轮到 (三) 呢。现在是 (1) 的回合。

我们进行计算比对发现顶端节点与p的距离比L还要更远，因此不进行更新。

![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-88682456df157fe8e42208377caee79c_720w.png)


然后是 (2)，计算 p 和分割线的距离发现也是更远。

![img](6.%E6%90%9C%E7%B4%A2%E6%A0%91.assets/v2-2c668a39988f4666d92932d1fe1eedb5_720w.png)

因此也不需要检查另一个分枝。

然后执行 (三)，判断当前节点是顶点，因此计算完成！输出距离 p 最近的三个样本是 L=[(−6.88,−5.4),(1.24,−2.86),(−2.96,−2.5)]。

### BBF优化

kd树实质上解决的问题是多维空间上的数据划分与搜索。但是，当维度越高时，搜索效率越差。可以用BBF（Best-Bin-First，优先级队列）优化搜索速度。

维度越高时，搜索效率越差：原因是维度高时回溯次数比较大。

为了降低回溯次数，应该限制回溯次数上限。为了保证在最大回溯次数内找到的最近邻比较接近真实最近邻，需要利用优先级队列。核心思想：每分支离目标点距离和相交情况不一。

BBF（Best Bin First）是一种改进的k-d树最近邻查询算法。标准的k-d树查询过程可以看出其搜索过程中的“回溯”是由“查询路径”来决定的，并没有考虑查询路径上数据点本身的一些性质。BBF的查询思路就是将“查询路径”上的节点进行排序，如按各自分割超平面（称为Bin）与查询点的距离排序。回溯检查总是从优先级最高的（Best Bin）的树节点开始。另外BBF还设置了一个运行超时限制，当优先级队列中的所有节点都经过检查或者超出时间限制时，算法返回当前找到的最好结果作为近似的最近邻。采用了best-bin-first search方法就可以将k-d树扩展到高维数据集上。

过程：

1. 查找Q的当前最近邻点P：

   从根结点开始，将Q与中间结点node(k,m)进行比较，根据比较结果选择某个树分支Branch（或称为Bin）；并将未被选择的另一个树分支所在的树中位置和它跟Q之间的距离一起保存到一个优先级队列中Queue；

   按照步骤1）的过程，对树分支Branch进行如上比较和选择，直至访问到叶子结点，然后计算Q与叶子结点中保存的数据之间的距离，并记录下最小距离D以及对应的数据P。

2. BBF回溯：已知最大回溯次数BTmax

   如果当前回溯的次数小于BTmax，且Queue不为空，则从Queue中取出最小距离对应的Branch，然后按照1步骤访问该Branch直至达到叶子结点；计算Q与叶子结点中各个数据间距离，如果有比D更小的值，则将该值赋给D，该数据则被认为是Q的当前近似最近邻点；

   重复1）步骤，直到回溯次数大于BTmax或Queue为空时，查找结束，此时得到的数据P和距离D就是Q的近似最近邻点和它们之间的距离。
