# 高级排序算法

## 快速排序

与归并排序算法一样，快速排序(quicksort)算法也是分治策略的典型应用，但是二者之间也有本质区别。归并排序的计算量主要消耗于有序子向量的归并操作，而子向量的划分却几乎不费时间。快速排序恰好相反，它可以在$O(1)$时间内，由子问题的解直接得到原问题的解；但为了将原问题划分为两个子问题，却需要$O(n)$时间。

快速排序算法虽然能够确保，划分出来的子任务彼此独立，并且其规模总和保持渐进不变，却不能保证两个子任务的规模大体相当——实际上甚至有可能极不平衡。因此该算法并不能保证最坏情况下的$O(n \log n)$时间复杂度。但是它往往成为首选的排序算法，因为快速排序算法易于实现，代码结构紧凑简练，而且对于按通常规律随机分布的输入序列，快速排序算法实际的平均运行时间较之同类算法更少。

![image-20211223175950302](12.%E6%8E%92%E5%BA%8F.assets/image-20211223175950302.png)

按照以上思路，可作为向量的一种排序器，实现快速排序算法：

```C++
template <typename T> //向量快速排序
void Vector<T>::quickSort(Rank lo, Rank hi){//0 <= lo < hi <= size
    if( hi - lo < 2){//单元素区间自然有序，否则...
        return;
    }
    Rank mi = partition( lo, hi - 1);//在 [lo, hi -1]内构造轴点
    quickSort ( lo, mi);
    quickSort( mi + 1, hi); 
}
```

算法的核心即在于：轴点构造算法partition()应如何实现？可以达到多高的效率？

![image-20211223180656302](12.%E6%8E%92%E5%BA%8F.assets/image-20211223180656302.png)

```C++
template <typename T> //轴点构造算法：通过调整元素位置构造区间[lo,hi]的轴点，并返回其秩
Rank Vector<T>::partition(Rank lo, Rank hi){//版本A：基本形式
    swap ( _elem[lo], _elem[lo + rand() % ( hi - lo + 1 ) ] ); //任选一个元素与首元素交换
    T pivot = _elem[lo];//以首元素为候选轴点——经以上交换，等效于随机选取
    while( lo < hi){//从向量的两端交替地向中间扫描
        while ( ( lo < hi ) && ( pivot <= _elem[hi] ) ){//在不小于pivot的前提下
            hi-- ;
        }
        _elem[lo] = _elem[hi]; //小于pivot者归入左侧子序列
        while ( ( lo < hi ) && ( _elem[lo] <= pivot ) ){//在不大于pivot的前提下
            lo++; //向右扩展左端子向量
        }
        _elem[hi] = _elem[lo];//大于pivot者归入右侧子序列
    } //assert: lo == hi
    _elem[lo] = pivot; //将备份的轴点记录置于前、后子向量之间
    return lo; //返回轴点的秩
}
```

![image-20211223183221051](12.%E6%8E%92%E5%BA%8F.assets/image-20211223183221051.png)

![image-20211223235857606](12.%E6%8E%92%E5%BA%8F.assets/image-20211223235857606.png)

复杂度分析：

![image-20211224000029918](12.%E6%8E%92%E5%BA%8F.assets/image-20211224000029918.png)

![image-20211224000131938](12.%E6%8E%92%E5%BA%8F.assets/image-20211224000131938.png)

![image-20211224002916946](12.%E6%8E%92%E5%BA%8F.assets/image-20211224002916946.png)

改进：

```C++
template <typename T> //轴点构造算法：通过调整元素位置构造区间[lo,hi]的轴点，并返回其秩
Rank Vector<T>::partition(Rank lo, Rank hi){//版本B：可优化处理多个关键码雷同的退化情况
    swap ( _elem[lo], _elem[lo + rand() % ( hi - lo + 1 ) ] ); //任选一个元素与首元素交换
    T pivot = _elem[lo];//以首元素为候选轴点——经以上交换，等效于随机选取
    while( lo < hi){//从向量的两端交替地向中间扫描
        while ( ( lo < hi ) && ( pivot <= _elem[hi] ) ){//在不小于pivot的前提下
            hi-- ;
        }
        _elem[lo] = _elem[hi]; //小于pivot者归入左侧子序列
        while ( ( lo < hi ) && ( _elem[lo] <= pivot ) ){//在不大于pivot的前提下
            lo++; //向右扩展左端子向量
        }
        _elem[hi] = _elem[lo];//大于pivot者归入右侧子序列
    } //assert: lo == hi
    _elem[lo] = pivot; //将备份的轴点记录置于前、后子向量之间
    return lo; //返回轴点的秩
}
```

较之版本A，版本B主要是调整了两个内循环的终止条件。以前一内循环为例，原条件`pivot <= _elem[hi]  `在此更改为`pivot < _elem[hi]  `，也就是说，一旦遇到重复元素，右端子向量随即终止拓展，并将右端重复元素转移至左端。因此，若将版本A的策略归纳为“勤于拓展、懒于交换”，版本B的策略则是“懒于拓展、勤于交换”。

![image-20211224214357082](12.%E6%8E%92%E5%BA%8F.assets/image-20211224214357082.png)

## 选取与中位数

![image-20211224214942093](12.%E6%8E%92%E5%BA%8F.assets/image-20211224214942093.png)

![image-20211224215010057](12.%E6%8E%92%E5%BA%8F.assets/image-20211224215010057.png)

可以先来讨论中位数问题的一个简化版本，在任一无序向量中，若有一半以上元素的数值同为m，则将m称作A的众数(majority)。

> 注意这里众数的概念和数学上不同

![image-20211224215346484](12.%E6%8E%92%E5%BA%8F.assets/image-20211224215346484.png)

但是，在尚得到高效的中位数查找算法之前，又该如何解决众数问题呢？

![image-20211224215527208](12.%E6%8E%92%E5%BA%8F.assets/image-20211224215527208.png)

![image-20211224215650319](12.%E6%8E%92%E5%BA%8F.assets/image-20211224215650319.png)

继续讨论中位数问题的另一简化版本，讨论：任给有序向量$S_{1}$ 和$S_{2}$，如何找出它们归并后所得有序向量$S=S_{1} \cup S_{2}$的中位数。

![image-20211225000352340](12.%E6%8E%92%E5%BA%8F.assets/image-20211225000352340.png)

按这两者归并，则需花费$O\left(n_{1}+n_{2}\right)$时间，但是未能充分利用“两个子向量已经有序”的条件。

![image-20211225002618505](12.%E6%8E%92%E5%BA%8F.assets/image-20211225002618505.png)

![image-20211225002630198](12.%E6%8E%92%E5%BA%8F.assets/image-20211225002630198.png)

因为属于尾递归，所以不难将该算法改写为迭代形式。

以上算法可以推广至一般情况，即允许有序向量$\mathrm{S}_{1}$ 和 $\mathrm{S}_{2}$的长度不等。

```C++
template <typename T> //向量S1[lo1, lo1 + n1)和S2[lo2, lo2 + n2)分别有序，数据项可能重复
T median ( Vector<T>& S1, int lo1, int n1, Vector<T>& S2, int lo2, int n2 ) { //中位数算法
    if ( n1 > n2 ) return median ( S2, lo2, n2, S1, lo1, n1 ); //确保n1 <= n2
    if ( n2 < 6 ) //递归基：1 <= n1 <= n2 <= 5
       return trivialMedian ( S1, lo1, n1, S2, lo2, n2 );
    ///////////////////////////////////////////////////////////////////////
    //                lo1            lo1 + n1/2      lo1 + n1 - 1
    //                 |                 |                 |
    //                 X >>>>>>>>>>>>>>> X >>>>>>>>>>>>>>> X
    // Y .. trimmed .. Y >>>>>>>>>>>>>>> Y >>>>>>>>>>>>>>> Y .. trimmed .. Y
    // |               |                 |                 |               |
    // lo2     lo2 + (n2-n1)/2       lo2 + n2/2     lo2 + (n2+n1)/2    lo2 + n2 -1
    ///////////////////////////////////////////////////////////////////////
    if ( 2 * n1 < n2 ) //若两个向量的长度相差悬殊，则长者（S2）的两翼可直接截除
       return median ( S1, lo1, n1, S2, lo2 + ( n2 - n1 - 1 ) / 2, n1 + 2 - ( n2 - n1 ) % 2 );
    ///////////////////////////////////////////////////////////////////////
    //    lo1                  lo1 + n1/2              lo1 + n1 - 1
    //     |                       |                       |
    //     X >>>>>>>>>>>>>>>>>>>>> X >>>>>>>>>>>>>>>>>>>>> X
    //                             |
    //                            m1
    ///////////////////////////////////////////////////////////////////////
    //                            mi2b
    //                             |
    // lo2 + n2 - 1         lo2 + n2 - 1 - n1/2
    //     |                       |
    //     Y <<<<<<<<<<<<<<<<<<<<< Y ...
    //                                .
    //                               .
    //                              .
    //                             .
    //                            .
    //                           .
    //                          .
    //                         ... Y <<<<<<<<<<<<<<<<<<<<< Y
    //                             |                       |
    //                       lo2 + (n1-1)/2               lo2
    //                             |
    //                            mi2a
    ///////////////////////////////////////////////////////////////////////
    int mi1  = lo1 + n1 / 2;
    int mi2a = lo2 + ( n1 - 1 ) / 2;
    int mi2b = lo2 + n2 - 1 - n1 / 2;
    if ( S1[mi1] > S2[mi2b] ) //取S1左半、S2右半
       return median ( S1, lo1, n1 / 2 + 1, S2, mi2a, n2 - ( n1 - 1 ) / 2 );
    else if ( S1[mi1] < S2[mi2a] ) //取S1右半、S2左半
       return median ( S1, mi1, ( n1 + 1 ) / 2, S2, lo2, n2 - n1 / 2 );
    else //S1保留，S2左右同时缩短
       return median ( S1, lo1, n1, S2, mi2a, n2 - ( n1 - 1 ) / 2 * 2 );
 }
```

这里也采用了减而治之的策略，可使问题的规模大致按几何级数递减，故整体复杂度亦为$O\left(\log \left(n_{1}+n_{2}\right)\right)$，更精确地，其复杂度应为$O\left(\log \left(\min \left(n_{1}, n_{2}\right)\right)\right)$，也就是说，子向量长度相等或接近时，此类问题的难度更大。

更普遍的，这其实是一种寻找第k小数字的算法：

我们一次遍历就相当于去掉不可能是中位数的一个值，也就是一个一个排除。由于数列是有序的，其实我们完全可以一半儿一半儿的排除。假设我们要找第 `k` 小数，我们可以每次循环排除掉 `k/2` 个数。看下边一个例子。

假设我们要找第 7 小的数字。

![image.png](12.%E6%8E%92%E5%BA%8F.assets/735ea8129ab5b56b7058c6286217fa4bb5f8a198e4c8b2172fe0f75b29a966cd-image.png)

我们比较两个数组的第 `k/2` 个数字，如果 `k` 是奇数，向下取整。也就是比较第 33 个数字，上边数组中的 44 和下边数组中的 33，如果哪个小，就表明该数组的前 `k/2` 个数字都不是第 `k` 小数字，所以可以排除。也就是 11，22，33 这三个数字不可能是第 77 小的数字，我们可以把它排除掉。将 13491349 和 4567891045678910 两个数组作为新的数组进行比较。

更一般的情况 `A[1]` ，`A[2]` ，`A[3]`，`A[k/2]` ... ，`B[1]`，`B[2]`，`B[3]`，`B[k/2]` ... ，如果 `A[k/2]`<`B[k/2]` ，那么`A[1]`，`A[2]`，`A[3]`，`A[k/2]`都不可能是第 `k` 小的数字。

`A` 数组中比 `A[k/2]` 小的数有 `k/2-1` 个，`B` 数组中，`B[k/2]` 比 `A[k/2]` 小，假设 `B[k/2]` 前边的数字都比 `A[k/2]` 小，也只有 `k/2-1` 个，所以比 `A[k/2]` 小的数字最多有 `k/1-1+k/2-1=k-2`个，所以 `A[k/2]` 最多是第 `k-1` 小的数。而比 `A[k/2]` 小的数更不可能是第 `k` 小的数了，所以可以把它们排除。

橙色的部分表示已经去掉的数字。

![image.png](12.%E6%8E%92%E5%BA%8F.assets/09b8649cd2b8bbea74f7f632b098fed5f8404530ff44b5a0b54a360b3cf7dd8f-image.png)

由于我们已经排除掉了 3 个数字，就是这 3 个数字一定在最前边，所以在两个新数组中，我们只需要找第 7 - 3 = 4 小的数字就可以了，也就是 k = 4。此时两个数组，比较第 2 个数字，3 < 5，所以我们可以把小的那个数组中的 1 ，3 排除掉了。

![image.png](12.%E6%8E%92%E5%BA%8F.assets/f2d72fd3dff109ad810895b9a0c8d8782f47df6b2f24f9de72704961bc547fcb-image.png)

我们又排除掉 2 个数字，所以现在找第 4 - 2 = 2 小的数字就可以了。此时比较两个数组中的第 k / 2 = 1 个数，4 == 4，怎么办呢？由于两个数相等，所以我们无论去掉哪个数组中的都行，因为去掉 1 个总会保留 1 个的，所以没有影响。为了统一，我们就假设 4 > 4 吧，所以此时将下边的 4 去掉。

![image.png](12.%E6%8E%92%E5%BA%8F.assets/3c89a8ea29f2e19057b57242c8bc37c5f09b6796b96c30f3d42caea21c12f294-image.png)

由于又去掉 1 个数字，此时我们要找第 1 小的数字，所以只需判断两个数组中第一个数字哪个小就可以了，也就是 4。

所以第 7 小的数字是 4。

我们每次都是取 `k/2` 的数进行比较，有时候可能会遇到数组长度小于 `k/2`的时候。

![image.png](12.%E6%8E%92%E5%BA%8F.assets/ad87d1f63a9bbd99e12605686290800ce61b03f9fb98d87f1d8c020d404421ac-image.png)

此时 k / 2 等于 3，而上边的数组长度是 2，我们此时将箭头指向它的末尾就可以了。这样的话，由于 2 < 3，所以就会导致上边的数组 1，2 都被排除。造成下边的情况。

![image.png](12.%E6%8E%92%E5%BA%8F.assets/7ea1963f184b1dcaddf951326ccbe7aa09cfbb9ebee7fffb2ede131853b3d1de-image.png)

由于 2 个元素被排除，所以此时 k = 5，又由于上边的数组已经空了，我们只需要返回下边的数组的第 5 个数字就可以了。

从上边可以看到，无论是找第奇数个还是第偶数个数字，对我们的算法并没有影响，而且在算法进行中，k 的值都有可能从奇数变为偶数，最终都会变为 1 或者由于一个数组空了，直接返回结果。

所以我们采用递归的思路，为了防止数组长度小于 `k/2`，所以每次比较 `min(k/2`，`len`(数组) 对应的数字，把小的那个对应的数组的数字排除，将两个新数组进入递归，并且 `k` 要减去排除的数字的个数。递归出口就是当 `k=1` 或者其中一个数字长度是 `0` 了。

### 基于优先级队列的选取

![image-20220101174504747](12.%E6%8E%92%E5%BA%8F.assets/image-20220101174504747.png)

### 基于快速划分的选取

![image-20220101174911051](12.%E6%8E%92%E5%BA%8F.assets/image-20220101174911051.png)

![image-20220101174930391](12.%E6%8E%92%E5%BA%8F.assets/image-20220101174930391.png)

### k选取算法

![image-20220101175024822](12.%E6%8E%92%E5%BA%8F.assets/image-20220101175024822.png)

![image-20220101175045504](12.%E6%8E%92%E5%BA%8F.assets/image-20220101175045504.png)

![image-20220101175114317](12.%E6%8E%92%E5%BA%8F.assets/image-20220101175114317.png)

![image-20220101175126872](12.%E6%8E%92%E5%BA%8F.assets/image-20220101175126872.png)

## 希尔排序

![image-20211225011047297](12.%E6%8E%92%E5%BA%8F.assets/image-20211225011047297.png)

若原一维向量为A[0, n)，则对于任一固定的矩阵宽度w， A与B中元素之间总有一一对应关系： ` B[i][j] = A[iw + j]`   或 `A[k] = B[k / w][k % w]  `

从秩的角度来看, 矩阵B的各列依次对应于整数子集 $[0, n)$ 关于宽度w的某一同余类。这也等效于从上到下、自左而右地将原向量A中的元素, 依次填入矩阵B的各个单元。

为简化起见, 以下不妨假设w整除 $n$ 。如此, $B$ 中同属一列的元素自上而下依次对应于 $A$ 中以 $w$ 为间隔的 $n / w$ 个元素。因此, 矩阵的宽度 $w$ 亦称作增量 (increment)。

![image-20211225011518048](12.%E6%8E%92%E5%BA%8F.assets/image-20211225011518048.png)

![image-20211225011958102](12.%E6%8E%92%E5%BA%8F.assets/image-20211225011958102.png)

![image-20211225012113845](12.%E6%8E%92%E5%BA%8F.assets/image-20211225012113845.png)

![image-20211225012236077](12.%E6%8E%92%E5%BA%8F.assets/image-20211225012236077.png)

![image-20211225012639814](12.%E6%8E%92%E5%BA%8F.assets/image-20211225012639814.png)

![image-20211225012724645](12.%E6%8E%92%E5%BA%8F.assets/image-20211225012724645.png)

![image-20211225012903322](12.%E6%8E%92%E5%BA%8F.assets/image-20211225012903322.png)

![image-20211225014616941](12.%E6%8E%92%E5%BA%8F.assets/image-20211225014616941.png)

![image-20211225014655490](12.%E6%8E%92%E5%BA%8F.assets/image-20211225014655490.png)

![image-20211225014717865](12.%E6%8E%92%E5%BA%8F.assets/image-20211225014717865.png)

![image-20211225014739727](12.%E6%8E%92%E5%BA%8F.assets/image-20211225014739727.png)

```C++
 template <typename T> //向量希尔排序
 void Vector<T>::shellSort ( Rank lo, Rank hi ) { //0 <= lo < hi <= size <= 2^30
    for ( int d = 0x3FFFFFFF; 0 < d; d >>= 1 ) //PS Sequence: { 1, 3, 7, 15, ..., 1073741823 }
       for ( int j = lo + d; j < hi; j++ ) { //for each j in [lo+d, hi)
          T x = _elem[j]; int i = j - d;
          while ( lo <= i && _elem[i] > x )
             { _elem[i + d] = _elem[i]; i -= d; }
          _elem[i + d] = x; //insert [j] into its subsequence
       }
 }
```

